<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java String类</title>
      <link href="/tantian123.github.io/2020/05/21/java-String%E7%B1%BB/"/>
      <url>/tantian123.github.io/2020/05/21/java-String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/tantian123.github.io/2020/05/21/java%E9%9B%86%E5%90%88/"/>
      <url>/tantian123.github.io/2020/05/21/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 面向面试编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http总结</title>
      <link href="/tantian123.github.io/2020/05/20/http%E6%80%BB%E7%BB%93/"/>
      <url>/tantian123.github.io/2020/05/20/http%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>现代网络应用的两种主流体系结构：<br>C/S 客户端/服务器   例子有WEB应用程序<br>P2P 对等</p><p>套接字是一台主机的应用层和传输层之间的<strong>接口</strong><br>进程（应用层）通过套接字接口访问TCP（传输层）</p><p>URL地址=主机名+对象的路径名</p><p>HTTP作用 (超文本传输协议)<br>定义了 浏览器如何向万维网服务器请求万维网文档,以及服务器如何将文档传给浏览器</p><p>HTTP使用TCP，而不是UDP作为它的运输层协议。因此不用担心数据丢失，TCP作为一层抽象屏蔽了底层的细节，HTTP不用管数据的传输。</p><p>HTTP是无状态协议,服务器不保存任何客户端的信息。</p><p>持久连接（长连接） 默认方式<br>所有请求及响应 经由相同的TCP连接<br>非持久连接（短连接）<br>所有请求及响应 经由分别的TCP连接</p><p>优缺点：</p><p>HTTP1.0 HTTP1.1<br>HTTP1.0每一个命令和应答都会触发TCP的连接和断开<br>而HTTP1.1允许在一个TCP上进行多次命令和应答</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>默认使用80端口，客户端向服务器的80端口建立一个TCP连接</p><p>1.浏览器分析URL<br>2.浏览器向dns服务器请求解析IP地址<br>3.DNS解析出IP地址<br>4.浏览器与服务器建立TCP连接<br>5.请求文件-响应<br>6.关闭TCP连接<br>7.浏览器显示</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp面试题</title>
      <link href="/tantian123.github.io/2020/05/20/tcp%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/tantian123.github.io/2020/05/20/tcp%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="tcp总结"><a href="#tcp总结" class="headerlink" title="tcp总结"></a>tcp总结</h1><ul><li><p>tcp/udp首部报文</p></li><li><p>三次握手 四次挥手 状态变换</p></li><li><p>tcp的流量控制</p></li><li><p>tcp的拥塞控制</p></li><li><p>常见的面试题</p></li></ul><p>tcp连接的每一端口，都由一个接收缓存、一个发送缓存和几个变量（lastByteRead RcvWindow Conwin）</p><p>RTT 往返时延<br>分组从客户端到服务器再回到客户端的时间<br>=分组传播时延+路由器/交换机上的排队时延+分组处理时延</p><h2 id="1-tcp-udp报文"><a href="#1-tcp-udp报文" class="headerlink" title="1.tcp/udp报文"></a>1.tcp/udp报文</h2><p>tcp报文=tcp首部字段+数据字段<br>源端口，目的端口，序号seq，确认号ack，控制位（ACK SYN FIN）,窗口</p><p><img src="/images/1.jpg" alt="tcp"></p><p>控制位 是6bit</p><p>udp报文=源端口号+目的端口号+长度（总长度）+校验和+数据字段</p><h3 id="tcp-udp的区别"><a href="#tcp-udp的区别" class="headerlink" title="tcp/udp的区别"></a>tcp/udp的区别</h3><ul><li>tcp 面向连接 可靠 面向字节流<br>udp 无连接 不可靠 面向报文</li><li>TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多</li><li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。TCP通过慢开始、拥塞避免、快重传、快恢复等算法进行拥塞控制。</li><li>UDP首开销小，只有8个字节。TCP首部是20个字节</li></ul><h2 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2.三次握手 四次挥手"></a>2.三次握手 四次挥手</h2><p><strong>主要关注控制位，序号，确认号，状态</strong><br><img src="/images/2.jpg" alt="tcp"></p><p>序列号/确认号的作用<br>序列号：<br>每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号<br>确认号：<br>告诉对方我已经收到xx，下次期望收到对方下个报文段的第一个数据字节的序号（下次的第一个字节）</p><p>序列号保证了传输的数据包的顺序</p><p>用tcp发送了一个数据包后，会把它放到重发队列里，同时计时，<br>如果收到了这个包的确认信息，就会将这个包从重发队列中删除，<br>如果在计时器超时内，没收到确认信息，就会进行重发</p><p>初始序列号(ISN) 是随机值  有client_isn和server_isn</p><h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1.三次握手"></a>2.1.三次握手</h3><ol><li><p>SYN=1 seq=x （也就是client_isn）<br>客户端发送SYN包到服务器<br>此后，客户端状态SYN_SENT</p></li><li><p>ACK=1 SYN=1 seq=y（也就是server_isn） ack=x+1<br>服务器收到SYN包，服务器返回SYNACK包，<br>此后，服务器状态SYN_RECV</p></li><li><p>ACK=1 seq=x+1  ack=y+1  SYN=0<br>客户端收到SYNACK包，发送ACK包给服务器<br>服务器收到<br>此后，客户端/服务器状态 ESTABLISHED（TCP连接成功）</p></li></ol><p>通过三次握手，通信双方了解了如下信息<br>1、对方报文发送的开始序号。<br>2、对方发送数据的缓冲区大小。<br>3、能被接收的最大报文段长度MSS。<br>4、被支持的TCP选项。</p><p>另一种理解，通过三次握手，通信双方都明确自己和对方的收、发能力是正常的<br>第一次握手（服务器端知道自己的收能力，和客户端的发能力）<br>第二次握手（客户端知道自己的收发能力和服务器端的收发能力）<br>第三次握手（服务器知道自己的发能力和客户端的收能力）</p><h3 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2.四次挥手"></a>2.2.四次挥手</h3><ol><li><p>FIN=1 ACK=1 seq=x ack=z<br>客户端发出连接释放报文<br>此后，客户端状态FIN_WAIT_1</p></li><li><p>ACK=1 seq=z ack=x+1<br>服务器收到后，发出确认报文（此时服务器还没发完，不能关闭）<br>此后，客户端状态  FIN_WAIT_1<br>服务器端状态  CLOSE_WAIT</p></li><li><p>FIN=1 ACK=1 seq=y ack=x+1<br>服务器传完后，就发送连接释放报文<br>此后，服务器状态LAST_ACK </p></li><li><p>ACK=1 seq=x+1 ack=y+1<br>客户端收到连接释放报文，发出确认报文<br>此后，客户端进入TIME_WAIT状态</p></li></ol><p>此时还要等待2MSL（最长报文段寿命）客户端才撤销TCB 进入CLOSED状态<br>服务器端收到客户端的确认报文，立刻进入CLOSED状态，所以服务器结束得早一点</p><h2 id="3-tcp流量控制"><a href="#3-tcp流量控制" class="headerlink" title="3.tcp流量控制"></a>3.tcp流量控制</h2><p>tcp让发送方维护一个接收窗口的变量来实现流量控制   RcvWindow<br>接收窗口用于告诉发送方，你的接收方还有多少缓存可用<br>两边都各自维护一个接收窗口，同时TCP不允许缓存溢出<br>主机B把当前的接收窗口值放入它发给主机A的TCP报文段里的接收窗口字段，通过控制未确认的数据量在接收窗口以内</p><p>当然，这个方案存在一个技术问题，<br>考虑一种特殊情况，当接收方B缓存满了，那么发送方A的接收窗口设为0，而之后如果接收方B缓存清空，发送方A就一直阻塞，不发。<br>解决方案：TCP规约中要求，接收窗口为0时，发送方A会继续发送只有一个字节的报文段，一旦缓存清空了，接收方B就会返回一个非0的窗口值。</p><h2 id="4-tcp拥塞控制"><a href="#4-tcp拥塞控制" class="headerlink" title="4.tcp拥塞控制"></a>4.tcp拥塞控制</h2><p>每一端都记录一个变量——拥塞窗口，CongWin。<br>它对一个TCP发送方，发送的速率进行了限制。<br>即 发送方未确认的数据量   (LastByteSend-LastByteAcked)&lt;=min(CongWin,RcvWindow)</p><p>TCP是如何感知阻塞的呢？</p><p>解决办法：<br>1.慢启动<br>2.拥塞避免<br>3.快重传<br>4.快恢复</p><h2 id="5-常见的面试题"><a href="#5-常见的面试题" class="headerlink" title="5.常见的面试题"></a>5.常见的面试题</h2><p>为什么需要初始序号<br>    为了避免安全攻击。初始序号是随机的<br>为什么不是二次握手<br>    主要为了防止A已失效的连接请求报文段突然又传送到了B，因而产生错误。如果没有第三次握手，B收到消息就会立马建立连接。<br>为什么要等待2MSL/为什么需要TIME_WAIT<br>    MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”<br>    为了保证A发送的最后一个ACK报文能够到达B ，如果A不等待，此时B没收到A的ACK，B就不会关闭</p><p>TIME_WAIT的危害<br>    在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态（大量TIME_WAIT的条件：高并发，服务器主动关闭）<br>    服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。<br>如何解决<br>    允许端口可重用<br>    服务器不主动关闭连接</p><p>为什么是四次挥手（关键在于挥手是需要等的，而握手是随时可以的）<br>    第一次挥手 A不主动发了，仍然可以接收<br>    第二次挥手 B告诉A 我知道你的情况了 但是我还没发完，等会<br>    第三次挥手 B告诉A 我处理完了，我不主动发了<br>    第四次挥手 A告诉B 你可以关闭接收了</p><p>syn洪泛攻击<br>    服务器响应SYN 会分配并初始化变量和缓存，消耗资源<br>    攻击者发送大量的TCP SYN报文段，而不进行第三次握手。导致服务器资源消耗殆尽。<br>    现在的防御手段，SYN cookies<br>三次握手过程中可以携带数据吗<br>    第三次握手允许携带数据<br>linux系统的nmap工具 （端口扫描工具）<br>    没用过</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向面试编程 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 136. Single Number</title>
      <link href="/tantian123.github.io/2020/04/02/leetcode-136-Single-Number/"/>
      <url>/tantian123.github.io/2020/04/02/leetcode-136-Single-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>这是一道Bit Operation位操作的题目<br>异或XOR操作：相同为0，不同为1<br>相同元素出现两次即出现两次变号  0-&gt;1-&gt;0(或1-&gt;0-&gt;1)<br>只出现一次的元素只变号一次     0-&gt;1(或1-&gt;0)</p><p>文字描述不够直观<br><strong>接下来直接举例，[1,2,3,4,1,2,3]  输出4</strong><br>res=1 ^ 2 ^ 3 ^ 4 ^ 1^ 2 ^ 3=(1 ^ 1) ^ (2 ^ 2)^(3 ^ 3)^ 4=0^ 0^ 0^4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1] -&gt; 0-0-0-1   //与下面的进行异或操作</span><br><span class="line">[2] -&gt; 0-0-1-0   //(0-0-0-1)+(0-0-1-0)=(0-0-1-1) </span><br><span class="line">[3] -&gt; 0-0-1-1   //(0-0-1-1)+(0-0-1-1)=(0-0-0-0)</span><br><span class="line">[4] -&gt; 0-1-0-0   //(0-0-0-0)+(0-1-0-0)=(0-1-0-0)</span><br><span class="line">[1] -&gt; 0-0-0-1   //(0-1-0-0)+(0-0-0-1)=(0-1-0-1)</span><br><span class="line">[2] -&gt; 0-0-1-0   //(0-1-0-1)+(0-0-1-0)=(0-1-1-1)</span><br><span class="line">[3] -&gt; 0-0-1-1   //(0-1-1-1)+(0-0-1-1)=(0-1-0-0)</span><br><span class="line">//最后输出结果为0-1-0-0，即为十进制数4.</span><br></pre></td></tr></table></figure><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>java进行按位异或操作  c = a ^ b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">            nums[i]=nums[i-1]^nums[i];</span><br><span class="line">        return nums[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo命令</title>
      <link href="/tantian123.github.io/2020/04/02/hexo%E5%91%BD%E4%BB%A4/"/>
      <url>/tantian123.github.io/2020/04/02/hexo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line">简写为</span><br><span class="line">hexo n &quot;我的博客&quot;</span><br></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate </span><br><span class="line">简写为</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">简写为</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h3 id="预览博文效果"><a href="#预览博文效果" class="headerlink" title="预览博文效果"></a>预览博文效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug 在本地浏览器的localhost:4000</span><br></pre></td></tr></table></figure><h3 id="三连"><a href="#三连" class="headerlink" title="三连"></a>三连</h3><p>在blog根目录下的source文件夹中的_post文件夹中打开命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="导入图片"><a href="#导入图片" class="headerlink" title="导入图片"></a>导入图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![简介](/images/xx.jpg)</span><br></pre></td></tr></table></figure><h3 id="新增分类选项"><a href="#新增分类选项" class="headerlink" title="新增分类选项"></a>新增分类选项</h3><p>一篇文章只会添加到一个分类中</p><p>1.创建分类页面（第一次才要）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>2.找到source/categories/index.md<br>加入一个键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: categories</span><br></pre></td></tr></table></figure><p>3.给每篇文章加属性<br>给文章添加“categories”属性<br>表示添加到到“Hexo”这个分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="新增标签选项"><a href="#新增标签选项" class="headerlink" title="新增标签选项"></a>新增标签选项</h3><p>一篇文章有多个标签</p><p>1.生成“标签”页并添加tpye属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>2.在tags文件夹下，找到index.md这个文件<br>加入一个键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: tags</span><br></pre></td></tr></table></figure><p>3.为其添加tags属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">- 日记</span><br><span class="line">- 2020</span><br><span class="line">- 私密</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
