<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PriorityQueue使用</title>
    <url>/tantian123.github.io/2020/06/06/PriorityQueue%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>PriorityQueue优先队列<br>//满了之后，并不会自动替换元素</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>每次都能保证取出的元素是队列中权值最小的<br>可以通过comparator接口，实现排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>add offer  插入元素<br>element peek  获取队首<br>remove poll  删除队首并返回</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用构造函数</span></span><br><span class="line">PriorityQueue()</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)<span class="comment">//初始容量，指定的比较器</span></span><br></pre></td></tr></table></figure>


<p>使用匿名内部类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/tantian123.github.io/2020/06/05/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="什么是泛型-generic"><a href="#什么是泛型-generic" class="headerlink" title="什么是泛型  generic"></a>什么是泛型  generic</h1><p>将具体的类型参数化<br>只在编译期间有效，随后编译器会用具体的类型来代替它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//泛型加在类名的后面，&lt;&gt;里面的就是形参 一般写大写字母</span></span><br><span class="line">    <span class="comment">//可以定义多个 之间用逗号隔开</span></span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定,</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="为什么要泛型"><a href="#为什么要泛型" class="headerlink" title="为什么要泛型"></a>为什么要泛型</h1><p>早期java是没有泛型的，用Object类</p>
<p>泛型的作用是在编译期帮助发现错误并且增强可读性</p>
<ul>
<li>不需要强制转换，交给了编译器</li>
<li>编写时，就限制了类型 ，提高了代码可读性和稳定性</li>
</ul>
<h1 id="泛型是如何工作的-类型擦除"><a href="#泛型是如何工作的-类型擦除" class="headerlink" title="泛型是如何工作的  类型擦除"></a>泛型是如何工作的  类型擦除</h1><p>编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息</p>
<p>没有使用时，默认为Object类型</p>
]]></content>
  </entry>
  <entry>
    <title>java异常</title>
    <url>/tantian123.github.io/2020/06/05/java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h1><p>异常是发生在程序执行过程中阻碍程序正常执行的错误事件（阻碍正常运行的事件）</p>
<p>只要在Java语句执行中产生了异常，一个异常对象就会被创建，JRE就会试图寻找异常处理程序来处理异常。</p>
<h1 id="Java异常的分类"><a href="#Java异常的分类" class="headerlink" title="Java异常的分类"></a>Java异常的分类</h1><p>Throwable为顶层父类<br>Throwable分为Error类和Exception类。<br>Error类：程序无法处理的严重错误，我们不作处理，与操作者无关。如系统崩溃，内存不足，堆栈溢出等<br>Exception —— 异常：异常可以分为运行时异常和编译期异常</p>
<ul>
<li>RuntimeException及其子类：即运行时异常，不会被编译器所检测出来，我们必须修正代码。</li>
<li>非RuntimeException及其子类：即编译期异常，必须处理，否则程序编译无法通过。</li>
</ul>
<p>区别就是一个编译能通过，一个编译通不过。</p>
<p><img src="/images/throwable.jpg" alt="throwable"></p>
<h1 id="检查型异常和非检查型异常"><a href="#检查型异常和非检查型异常" class="headerlink" title="检查型异常和非检查型异常"></a>检查型异常和非检查型异常</h1><p>检查型异常  非RuntimeException及其子类<br>非检查型异常  Error类和RuntimeException及其子类</p>
<h1 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h1><p>try…catch…finally语句块<br>throws函数声明</p>
<p>特别的是：如果catch中有return语句，那么finally会在return执行之前执行。</p>
<h1 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h1><p>throw是语句抛出一个异常<br>throws是声明 方法可能抛出的异常</p>
<h1 id="final-finalize-finally关键字的区别"><a href="#final-finalize-finally关键字的区别" class="headerlink" title="final,finalize,finally关键字的区别"></a>final,finalize,finally关键字的区别</h1><p>首先，finalize是方法<br>final,finally是关键字<br>final修饰类、变量、方法 表示不能再继承/赋值/重写<br>finall用于异常处理代码块<br>finalize是Object类的方法，<br>在垃圾收集器执行的时候会调用被回收对象的finalize（）方法<br>实现资源的回收。</p>
<h1 id="如何自定义异常"><a href="#如何自定义异常" class="headerlink" title="如何自定义异常"></a>如何自定义异常</h1><p>创建自定义类继承Exception类<br>在方法中通过throw抛出异常<strong>对象</strong></p>
]]></content>
  </entry>
  <entry>
    <title>java除法和取模</title>
    <url>/tantian123.github.io/2020/06/05/java%E9%99%A4%E6%B3%95%E5%92%8C%E5%8F%96%E4%BD%99/</url>
    <content><![CDATA[<h1 id="取余和取模的区别"><a href="#取余和取模的区别" class="headerlink" title="取余和取模的区别"></a>取余和取模的区别</h1><p><strong>各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。</strong></p>
<p>取余，遵循尽可能让商向0靠近的原则<br>取模，遵循尽可能让商向负无穷靠近的原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于式子<span class="number">10</span>%-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">c++/java为 -<span class="number">3</span>  ...<span class="number">1</span><span class="comment">//取余</span></span><br><span class="line">python为   -<span class="number">4</span>  ...-<span class="number">2</span><span class="comment">//取模</span></span><br></pre></td></tr></table></figure>

<h1 id="java中的取余和取模"><a href="#java中的取余和取模" class="headerlink" title="java中的取余和取模"></a>java中的取余和取模</h1><p>Java 中的取余运算是 %，而取模运算是 Math.floorMod()</p>
<p><strong>取余运算的符号是根据第一个运算数决定的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">System.out.println(<span class="number">7</span> % <span class="number">4</span>);<span class="comment">//3</span></span><br><span class="line">System.out.println((-<span class="number">7</span>) % <span class="number">4</span>);<span class="comment">//-3</span></span><br><span class="line">System.out.println(<span class="number">7</span> % (-<span class="number">4</span>));<span class="comment">//3</span></span><br><span class="line">System.out.println((-<span class="number">7</span>) % (-<span class="number">4</span>));<span class="comment">//-3</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Integer相关知识</title>
    <url>/tantian123.github.io/2020/06/05/Integer%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Integer类详解"><a href="#Integer类详解" class="headerlink" title="Integer类详解"></a>Integer类详解</h1><p>基本数据类型  boolean、byte、int、char、long、short、double、float<br>引用数据类型  数组、类、接口<br>Integer是类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Integer重写了hashCode方法，返回值是value-即Integer对象-的数值。"><a href="#Integer重写了hashCode方法，返回值是value-即Integer对象-的数值。" class="headerlink" title="Integer重写了hashCode方法，返回值是value,即Integer对象 的数值。"></a>Integer重写了hashCode方法，返回值是value,即Integer对象 的数值。</h1><h1 id="Integer重写了equals方法-比较值-比较地址"><a href="#Integer重写了equals方法-比较值-比较地址" class="headerlink" title="Integer重写了equals方法 比较值   ==比较地址"></a>Integer重写了equals方法 比较值   ==比较地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        if (obj instanceof Integer) &#123;</span><br><span class="line">            return value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Integer-类和-int-的区别"><a href="#Integer-类和-int-的区别" class="headerlink" title="Integer 类和 int 的区别"></a>Integer 类和 int 的区别</h2><p>1.Integer是类型和int是基本数据类型<br>2.Integer默认值是null int默认值是0<br>3.Integer实际是对象的引用，而int则是直接存储数据值<br>4.baiInteger变量必须实例化后才能使用，而int变量不需要</p>
<h1 id="开箱和装箱"><a href="#开箱和装箱" class="headerlink" title="开箱和装箱"></a>开箱和装箱</h1><p>自动装箱和拆箱<br>在编译期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer a = <span class="number">128</span>;</span><br><span class="line">编译器转换为</span><br><span class="line">Integer a = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">int</span> b=a;</span><br><span class="line">编译器转换为</span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">int</span> b = a.intValue();</span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存只能在自动装箱或者是调用Integer.valueOf(int x)才会有用。</p>
<p>缓存的范围byte&lt;= 127、char&lt;=127、-128&lt;=short &lt;=127、-128&lt;=int &lt;=127</p>
<p>所有就有这么一道题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">127</span>;  </span><br><span class="line">Integer i2 = <span class="number">127</span>;  </span><br><span class="line">System.err.println(i1 == i2);  <span class="comment">//true</span></span><br><span class="line">      </span><br><span class="line">Integer i1 = <span class="number">128</span>;  </span><br><span class="line">Integer i2 = <span class="number">128</span>;  </span><br><span class="line">System.err.println(i1 == i2);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line">System.err.println(i3 == i4);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>Comparable和Comparator</title>
    <url>/tantian123.github.io/2020/06/04/Comparable/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>Comparable<br>Comparator</p>
<h1 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h1><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>为了排序</p>
<p>Comparator位于包java.util下，而Comparable位于包java.lang下</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承该接口，需要重写compareTo()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age()-p.age;<span class="comment">//比较的依据就是返回值是 大于0/小于0/等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Person&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.sort(arr);</span><br></pre></td></tr></table></figure>







<p>Comparator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>何时使用Comparator?<br>不改变类的原样，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.sort(<span class="keyword">new</span> PersonComparator());</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>hashmap原理</title>
    <url>/tantian123.github.io/2020/06/04/hashmap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>底层实现？<br>哈希表（数组+链表）<br>在hashmap有一个静态内部类Entry<br>其属性有key value next<br>hashmap的基础就是一个Entry[]数组</p>
<p>Entry&lt;K,V&gt;[] table;//只有在第一次put时才会初始化</p>
<p>JDK1.8 当链表长度超过8，链表转为红黑树</p>
<p>hashmap的重要字段<br>size 大小<br>threshold阈值=capacity<em>loadFactor  16</em>0.75<br>loadFactor负载因子  默认是0.75<br>modCount迭代次数</p>
<p>哈希桶的默认个数是16</p>
<p>方法的实现？<br>put</p>
<ul>
<li><p>hash<br>将大量的数据 转化为 定长</p>
</li>
<li><p>默认初始容量 16</p>
</li>
<li><p>hashmap的数组大小为什么是2的幂次方？<br>减少hash碰撞<br>数组长度2^n  那么二进制形式是1000…<br>那么长度length-1 的二进制形式是11111…<br>进行&amp;计算的时候，就不会有哈希桶是是空的了。</p>
</li>
<li><p>hashmap的默认容量</p>
</li>
<li><p>hashmap是线程安全的吗？为什么？</p>
</li>
<li><p>hashmap的扩容机制？<br>2*length<br>新开一个2倍长度的，然后将元素迁移过去 重新hash</p>
</li>
<li><p>1.7存在死锁问题<br>扩容rehash的时候形成了环形链表，存在查找的死循环</p>
</li>
<li><p>1.7存在bug<br>通过精心构造的恶意请求引发Dos<br>通过成千上万个相同hash值的数据，严重影响性能</p>
</li>
</ul>
<h1 id="hashtable-hashmap的区别"><a href="#hashtable-hashmap的区别" class="headerlink" title="hashtable hashmap的区别"></a>hashtable hashmap的区别</h1><p>都实现了map接口<br>hm允许键或者值为null   不同步<br>ht不允许键或者值为null  同步，线程安全<br>现在不推荐使用ht</p>
]]></content>
  </entry>
  <entry>
    <title>密码学复习</title>
    <url>/tantian123.github.io/2020/06/03/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>dubbo第一次使用</title>
    <url>/tantian123.github.io/2020/06/03/dubbo%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>linux 环境下zookeeper<br>jdk安装</p>
<p>zookeeper</p>
]]></content>
  </entry>
  <entry>
    <title>mysql学习笔记</title>
    <url>/tantian123.github.io/2020/06/01/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.使用终端操作数据库<br>1.1登录<br>管理员模式下 打开命令提示符cmd<br>net stop mysql<br>net start mysql</p>
<p>1.2连接<br>mysql -u用户名 -p密码</p>
<p>1.3查询所有数据库<br>show databases;<br>1.4选中某一个数据库进行操作(不选不能操作)<br>use 数据库名<br>1.5选中后，查询某一个表<br>show tables;<br>select * from user</p>
<p>1.6退出<br>exit</p>
<p>2.使用可视化工具操作数据库</p>
<p>3.在java中使用数据库</p>
<hr>
<p>创建数据库<br>create database test;</p>
<p>建表<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>)<br>删除表<br>drop table user;</p>
<p>查看表的结果<br>describe user;简写为desc</p>
<p>增加数据记录<br>insert into user values(1,’tt’,’tt123456789’);</p>
<hr>
<p>mysql常用数据类型</p>
<p>三类 ：数值 日期  字符串<br>选择依据数据类型的大小</p>
<p>1.数值<br>常用的是<br>SMALLINT 2字节<br>INT  4字节<br>BIGINT 8字节<br>FLOAT  4字节<br>DOUBLE 8字节<br>2.日期<br>DATE   格式是’YYYY-MM-DD’<br>TIME 格式是’HH-MM-SS’<br>3.字符串<br>CHAR 0-255字节  定长字符串<br>VARCHAR 0-65535字节 变长字符串<br>TEXT 0-65535字节</p>
<hr>
<p>增删改查<br>1.insert<br>insert into user values(1,’tt’,’tt123456789’);<br>2.delete<br>delete from user where name=’tt’<br>3.update<br>update user set name=’tt’ where id=’1’<br>4.select<br>select * from user where name=’tt’</p>
<hr>
<p>约束<br>添加约束可以在建表的时候，也可以之后加</p>
<p>1.主键约束primary key<br>唯一确定一张表中的一条记录 该字段不重复且不为空(不能为NULL，不能与之前的重复)<br>create table user(<br>    id INT primary key,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>)<br>联合主键  加起来不重复就行<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20),<br>    primary key（id,name)<br>)</p>
<p>建表时忘记主键约束，之后修改<br>alter table user add primary key(id);<br>删除主键约束<br>alter table user drop primary key;<br>修改主键约束<br>alter table user modify id int primary key;</p>
<p>2.自增约束auto_increment  和主键约束一起用 自动管控id的值<br>create table user(<br>    id INT primary key auto_increment,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>) </p>
<p>3.外键约束<br>涉及到两个表 主表 副表<br>foreign key指明外键来自于哪个表<br>主表里面不存在的值，副表不能有<br>主表中被副表引用了的值，是不可以删除的</p>
<p>create table user(<br>    id INT primary key,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>)<br>create table company(<br>    id INT primary key,<br>    money INT,<br>    user_id INT,<br>    foreign key(user_id) references user(id)<br>)</p>
<p>4.唯一约束unique 不可重复<br>create table user(<br>    id INT,<br>    name VARCHAR(20)  unique,<br>    pwd VARCHAR(20)<br>)<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20),<br>    unique(name,id,pwd) //加在一起不重复就可以<br>)</p>
<p>alter table user add unique(name);</p>
<p>删除唯一约束<br>alter table user drop index name;//这里不是unique是因为唯一约束有多个<br>修改唯一约束<br>alter table user modify name varchar(20) unique;<br>5.非空约束 不为null<br>create table user(<br>    id INT,<br>    name VARCHAR(20)  not null,<br>    pwd VARCHAR(20)<br>)<br>6.默认约束 default<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20) default ‘root’<br>)</p>
<hr>
<p>数据库的设计范式 NormalForm<br>1.第一范式 1NF<br><strong>各个属性不可再分</strong>（字段不可再分）<br>例如：表有地址这个属性，地址可以分为省、市、区、乡镇等，<br>所以整个地址设为一个字段，是不合理的。</p>
<p>2.第二范式 2NF<br>满足第一范式的基础上，要求非主属性对主属性是完全函数依赖，即<strong>不存在部分函数依赖</strong>（有主键，非主键列完全依赖于主键，不可以依赖主键的一部分）<br>例如：有这样一个表，它的字段有学生学号id，学生名字，课程编号id，课程名称<br>那么，课程名称是部分依赖主键（学生id,课程id）的，这样的表 不合理。<br>因为如果我没选课，这条数据就不能插入数据库。<br>所以需要划分为学生表和课程表。</p>
<p>3.第三范式 3NF<br>满足第二范式的基础上，要求<strong>不存在传递函数依赖</strong><br>例如：有这样一个表，学生学号id，学生证id，学生证说明。<br>那么，学生证说明是传递依赖于学生学号，不是直接依赖。<br>所以需要划分为学生表和学生证表。</p>
<p>4.BCNF<br>满足第三范式的基础上，不允许主键内部之间存在依赖<br>例如 主键为(学生，老师) 课程<br>这样的关系满足第三范式，但不满足BCNF范式</p>
<p>范式的优缺点:<br>减少冗余<br>结构清晰<br>性能降低</p>
<p>表之间关系的解释<br>一对一：学生和学生证   通过外键和唯一约束<br>一对多：学生和班级     通过外键<br>多对多：学生和老师     通过引入中间表</p>
<hr>
<p>与查询相关的知识<br>例子：<br>学生表 Student<br>学号 姓名 年龄 所在班级<br>课程表 Course<br>课程号，课程名称 教师编号<br>成绩表 Score<br>学号 课程号 成绩<br>老师表 Teacher<br>教师编号，教师名字，教师年龄</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    sname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    classid <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Teacher(</span><br><span class="line">    tid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    tname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(</span><br><span class="line">    cid <span class="built_in">varchar</span>(<span class="number">20</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    tid <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span>(tid) <span class="keyword">references</span> Teacher(tid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Score(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cid <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    score <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">sid</span>,cid),</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">sid</span>) <span class="keyword">references</span> Student(<span class="keyword">sid</span>),</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (cid) <span class="keyword">references</span> Course(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'谭天'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'罗杰'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'宋志豪'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'曾繁'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'xxx'</span>,<span class="string">'计科1000班'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'李老师'</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'刘老师'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'王老师'</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'孙老师'</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'1001'</span>,<span class="string">'语文课'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'1002'</span>,<span class="string">'数学课'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'1003'</span>,<span class="string">'英语课'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'2001'</span>,<span class="string">'理综课'</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1001'</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1002'</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1003'</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'2001'</span>,<span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'1002'</span>,<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">//问题</span><br><span class="line">1.查询学生的学号和名字</span><br><span class="line"></span><br><span class="line">2.查询学生的不重复的所在班级列 x 关键字</span><br><span class="line"></span><br><span class="line">3.查询成绩表 80-90分之间的记录</span><br><span class="line"></span><br><span class="line">4.查询成绩表 70 100或者90的记录</span><br><span class="line"></span><br><span class="line">5.查询老师 以年龄升序/降序</span><br><span class="line"></span><br><span class="line">6.查询计科1703班的人数</span><br><span class="line"></span><br><span class="line">7.查询最高分的学生的学号和对应的课程号（子查询或者排序后取第一个）x max函数</span><br><span class="line"></span><br><span class="line">8.查询学生1的平均分</span><br><span class="line"></span><br><span class="line">9.分别查询每名学生的平均分</span><br><span class="line"></span><br><span class="line">10.查询以'1'开头的课程的平均分 并且该课程至少有两人选择 </span><br><span class="line">having count关键字 xx</span><br><span class="line">先把至少两人选择的课程分组选出来 然后并上 like 1%</span><br><span class="line">最后在结果处计算平均分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,sname <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> classid <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="keyword">between</span> <span class="number">80</span> <span class="keyword">and</span> <span class="number">90</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> score &gt; <span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="keyword">in</span>(<span class="number">70</span>,<span class="number">90</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;//asc可省略</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,cid <span class="keyword">from</span> score <span class="keyword">where</span> score=(<span class="keyword">select</span> <span class="keyword">max</span>(score) <span class="keyword">from</span> score);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,cid <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">sid</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>，<span class="keyword">avg</span>(score) <span class="keyword">from</span> score </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>;</span><br><span class="line"></span><br><span class="line">//分层次</span><br><span class="line"><span class="keyword">select</span> cid,<span class="keyword">avg</span>(score) <span class="keyword">from</span> score </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cid</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">sid</span>)&gt;=<span class="number">2</span> </span><br><span class="line"><span class="keyword">and</span> cid <span class="keyword">like</span> <span class="string">'1%'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//问题</span><br><span class="line">1.多表查询</span><br><span class="line">查询 所有学生的名字 课程号 分数 sname cid score(分别在student表和score表)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname,cid,score <span class="keyword">from</span> student,score</span><br><span class="line"><span class="keyword">where</span> student.sid=score.sid;</span><br><span class="line"></span><br><span class="line">查询 所有学生的名字 课程名 分数 所在列</span><br><span class="line"><span class="keyword">select</span> sname,cname,score,student.sid <span class="keyword">as</span> stu_id,course.cid <span class="keyword">as</span> cou_id <span class="keyword">from</span> student,score,course</span><br><span class="line"><span class="keyword">where</span> student.sid=score.sid <span class="keyword">and</span> score.cid=course.cid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.子查询</span><br><span class="line">查询计科1703班学生每门课的平均分</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;)</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">select</span> cid,<span class="keyword">avg</span>(score) <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;) </span><br><span class="line">group by cid;</span><br></pre></td></tr></table></figure>




<hr>
<p>mysql的四种连接查询</p>
<p>内连接 把有关系的数据查询出来<br>inner join 或者join<br>外连接<br>1.左连接<br>left join 或者 left outer join<br>2.右连接<br>right join 或者 right outer join<br>3.完全外连接<br>full join  或者 full outer join</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">person表和card表</span><br><span class="line">person  id name cardID</span><br><span class="line">card    id name</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>;</span><br><span class="line">    name varchar(20);</span><br><span class="line">    cardID int</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> card(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>;</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> card <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'饭卡'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> card <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'银行卡'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'张三'</span>，<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'李四'</span>，<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'王五'</span>，<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">1.内连接 把有关系的数据查询出来</span><br><span class="line">这里故意没有外键</span><br><span class="line">那么 我们要使用 inner join查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">inner</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id;</span><br><span class="line"></span><br><span class="line">// on 表示连接条件</span><br><span class="line"></span><br><span class="line">2. left join  左边表内容全查出来；右边表有的显示，没有的补null</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id;</span><br><span class="line"></span><br><span class="line">3. right join  右边表内容全查出来；左边表有的显示，没有的补null</span><br><span class="line"></span><br><span class="line">4.mysql没有外连接</span><br><span class="line">使用union</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">inner</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id;</span><br></pre></td></tr></table></figure>






<hr>
<p>mysql事务</p>
<p>自动commit的开启和关闭</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//禁止默认的自动提交 <span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span> </span><br><span class="line">//开启自动提交 <span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'神秘人'</span>,<span class="string">'异次元'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>

<p>手动commit<br>begin;或者 start transaction;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'神秘人'</span>,<span class="string">'异次元'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>


<p>事务的隔离级别<br>1.read uncommitted;  读未提交<br>2.read committed;    读已提交<br>3.repeatable read;   可重复读<br>4.serializable;    可串行化</p>
<p>MySQL 数据库默认的事务隔离级别是 REPEATABLE_READ (可重复读)。</p>
<p>修改隔离级别<br>设置全局的事务隔离级别<br>set global transaction isolation level read committed;<br>设置本次会话的事务隔离级别<br>set session transaction isolation level read committed;</p>
]]></content>
  </entry>
  <entry>
    <title>mybatis学习</title>
    <url>/tantian123.github.io/2020/05/29/mybatis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>复制自 <a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<blockquote>
<p>持久层框架   完成持久化的代码块（内存-文件）<br>免除了几乎所有的 JDBC 代码<br>通过XML和注解<br>ORM 对象关系映射 将java面向对象的实体类 转换为 MYSQL的面向关系的表</p>
</blockquote>
<h1 id="为什么需要MyBatis？"><a href="#为什么需要MyBatis？" class="headerlink" title="为什么需要MyBatis？"></a>为什么需要MyBatis？</h1><p>传统的JDBC代码太复杂了，所以有了框架</p>
<p>映射 将对象映射标签<br>灵活，不对现有代码强加影响<br>解耦合，sql和代码分离<br>提供xml标签，支持动态sql</p>
<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>新建maven工程<br>pom.xml 导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-建表User"><a href="#2-建表User" class="headerlink" title="2.建表User"></a>2.建表User</h1><p>在数据库中新建user表</p>
<h1 id="3-建立表对应的实体类User（pojo）"><a href="#3-建立表对应的实体类User（pojo）" class="headerlink" title="3.建立表对应的实体类User（pojo）"></a>3.建立表对应的实体类User（pojo）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-创建Mybatis配置文件"><a href="#4-创建Mybatis配置文件" class="headerlink" title="4.创建Mybatis配置文件"></a>4.创建Mybatis配置文件</h1><p>在resource下，新建mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Mybatis运行环境 可以有多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置JDBC事务管理--&gt;</span><span class="comment">&lt;!----&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--dataSource是数据源  POOLED配置JDBC数据源连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--driver驱动  url哪个数据库 username用户名password密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"tt123456789"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册该usermapper.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由上面可见，配置文件的作用就是连接到数据库和注册mapper</p>
<h1 id="5-1使用原生接口-不推荐"><a href="#5-1使用原生接口-不推荐" class="headerlink" title="5.1使用原生接口  不推荐"></a>5.1使用原生接口  不推荐</h1><h3 id="1-mybatis框架需要开发者自定义sql语句，写在mapper-xml里面"><a href="#1-mybatis框架需要开发者自定义sql语句，写在mapper-xml里面" class="headerlink" title="1.mybatis框架需要开发者自定义sql语句，写在mapper.xml里面"></a>1.mybatis框架需要开发者自定义sql语句，写在mapper.xml里面</h3><p>实际开发中，会为每个实体类创建mapper.xml来定义管理该对象数据的sql</p>
<p>user.java  -&gt;  usermapper.xml</p>
<p>usermapper.xml如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapper 里面就是各种语句 insert标签就是insert语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace是带着包名的全路径 无后缀--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id是调用这句sql语句 调用的方法名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  parameterType就是调用这个方法传入的参数类型 例如User--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#&#123;userid&#125;意思就是 取得 User对象里面的userid字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        insert into User(id,name,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在全局配置文件中注册该usermapper-xml"><a href="#2-在全局配置文件中注册该usermapper-xml" class="headerlink" title="2.在全局配置文件中注册该usermapper.xml"></a>2.在全局配置文件中注册该usermapper.xml</h3><p>在后面加一个标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-调用mybatis原生接口实现操作"><a href="#3-调用mybatis原生接口实现操作" class="headerlink" title="3.调用mybatis原生接口实现操作"></a>3.调用mybatis原生接口实现操作</h3><p>在test测试类main函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 XML 中构建 SqlSessionFactory</span></span><br><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactoryBuilder sqlSessionFactoryBuilder=<span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line"><span class="comment">//从 SqlSessionFactory 中获取 SqlSession</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//调用方法 根据namespace.id调用</span></span><br><span class="line">String statement=<span class="string">"dao.UserMapper.insert"</span>;</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">"khan"</span>,<span class="number">26</span>);</span><br><span class="line">sqlSession.insert(statement,user);</span><br><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure>


<p>这里还有一个大坑！<br>java文件夹下的xml不会编译（和resource文件夹下不同）所以在Mybatis的配置文件中找不到xml文件</p>
<p>所以需要修改pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/mybatis1.jpg" alt="第一种方式的项目结构"></p>
<h1 id="5-2使用mapper代理"><a href="#5-2使用mapper代理" class="headerlink" title="5.2使用mapper代理"></a>5.2使用mapper代理</h1><p>使用mapper代理自定义接口 （推荐第二种方法）</p>
<ul>
<li>1.自定义接口，定义方法 （mapper会自动生成接口的实现类）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//自定义接口 不需要写它的实现类 写对应的mapper</span><br><span class="line">public interface UserRepository &#123;</span><br><span class="line">    public int save(User user);</span><br><span class="line">    public int update(User user);</span><br><span class="line">    public void delete(int id);</span><br><span class="line">    public List&lt;User&gt; findall();</span><br><span class="line">    public User select(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.编写与方法对应的UserRepository.xml文件 定义sql方法对应的接口的方法<br>UserRepository.xml 中namespace为接口的全类名  id为接口中对应的方法名<br>UserRepository.xml   元素和UserRepository.java一一对应<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapper 里面就是各种语句 insert标签就是insert语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace是接口的全路径 无后缀--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id是调用这句sql语句 调用的方法名  sqlsession调用的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  parameterType就是调用这个方法传入的参数类型 例如User--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#&#123;userid&#125;意思就是 取得 User对象里面的userid字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"repository.UserRepository"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        insert into User(id,name,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        update User set id=#&#123;id&#125;,name=#&#123;name&#125;,age=#&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from User where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findall"</span> <span class="attr">resultType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"select"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        select * from User where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>3.这个mapper也要注册<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"repository/UserRepository.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>4.使用<br>新建test2.java  在得到sqlsession之前的步骤是一样的<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 XML 中构建 SqlSessionFactory</span></span><br><span class="line">       String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">       InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">       SqlSessionFactoryBuilder sqlSessionFactoryBuilder=<span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">       SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">       <span class="comment">//从 SqlSessionFactory 中获取 SqlSession</span></span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       <span class="comment">//获取实现了接口的代理对象</span></span><br><span class="line">       UserRepository userRepository=sqlSession.getMapper(UserRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       List&lt;User&gt; list=userRepository.findall();</span><br><span class="line">       <span class="keyword">for</span>(User u:list)</span><br><span class="line">           System.out.println(u);</span><br></pre></td></tr></table></figure>






</li>
</ul>
<h1 id="执行一条SQL的过程总结"><a href="#执行一条SQL的过程总结" class="headerlink" title="执行一条SQL的过程总结"></a>执行一条SQL的过程总结</h1><p>实体类 mapper接口 mapper配置文件<br>1.通过 SqlSessionFactoryBuilder 构造 SqlSessionFactory 对象<br>2.SqlSessionFactory 通过 openSession() 方法获取 SqlSession 对象<br>3.通过 SqlSession 获得 mapper 代理对象<br>4.通过 mapper 代理对象执行数据库操作<br>5.执行成功，使用 SqlSession 提交事务，执行失败，使用 SqlSession 回滚事务</p>
<h1 id="解决属性名和字段名不一致的问题"><a href="#解决属性名和字段名不一致的问题" class="headerlink" title="解决属性名和字段名不一致的问题"></a>解决属性名和字段名不一致的问题</h1><p>问题：<br>如果User的属性名是password 数据库里面的字段名是pwd<br>查询出来的password会为null<br>原因：<br>通过类型处理器，它找不到pwd<br>如何解决：<br>1.起别名 select password as pwd from user;<br>2.resultMap 结果集映射<br>用来处理不能直接映射的情况</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findall"</span> <span class="attr">resultType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">改为</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findall"</span> <span class="attr">resultMap</span>=<span class="string">"UserMap"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果集映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--result 代表结果 colunm是列（数据库的字段）  property是属性（类的属性）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colunm</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colunm</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colunm</span>=<span class="string">"pwd"</span> <span class="attr">property</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>resultMap的设计思想，对于简单的语句不需要显示的结果映射，对于复杂的语句只需要描述它们的关系</strong></p>
<h1 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h1><p>两种实现方式：业务扩展类和resultmap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">两个表 学生表和学生证表</span><br><span class="line"></span><br><span class="line">学生表 字段为学号 学生姓名 学生证号</span><br><span class="line">学生证表 字段为 学生证号 学生证介绍</span><br><span class="line">class student&#123;</span><br><span class="line">    int sid;</span><br><span class="line">    String sname;</span><br><span class="line">    int cardid;</span><br><span class="line">&#125;</span><br><span class="line">class card&#123;</span><br><span class="line">    int cardid;</span><br><span class="line">    String cardmsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：如果我们要查询某个学生id 对应的全部信息</span><br><span class="line">1.扩展类方法 studentAndcard类 让业务扩展类包含所有要查的字段  resultType</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryStudentAndCardById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"pojo.studentAndcard"</span>&gt;</span></span><br><span class="line">select * from student scard where student.cardid=scard.cardid and s.id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UserRepository userRepository=sqlSession.getMapper(UserRepository.class);</span><br><span class="line">studentAndcard sc=userRepository.queryStudentAndCardById(id);</span><br><span class="line">System.out.println(sc);</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">2.resultmap方法</span><br><span class="line">用两个类分别接收</span><br><span class="line">如何建立二者之间的关系？</span><br><span class="line">把一个类作为另一个类的成员,从而建立联系</span><br><span class="line">class student&#123;</span><br><span class="line">    int sid;</span><br><span class="line">    String sname;</span><br><span class="line">    int cardid;</span><br><span class="line">    Card card;</span><br><span class="line">&#125;</span><br><span class="line">class card&#123;</span><br><span class="line">    int cardid;</span><br><span class="line">    String cardmsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不再使用resultType 使用resultMap</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryStudentAndCardById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"studentAndcard"</span>&gt;</span></span><br><span class="line">select * from student scard where student.cardid=scard.cardid and s.id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">//resultMap的type就是整个select语句的返回值  id就是resultMap的名字</span><br><span class="line">//这里使用student是因为它已经扩展了，他此时包含了card类</span><br><span class="line">//<span class="tag">&lt;<span class="name">id</span>&gt;</span>是主键 <span class="tag">&lt;<span class="name">result</span>&gt;</span>是搜索结果</span><br><span class="line">//对象成员  **一对一使用association   一对多使用collection**</span><br><span class="line">//javaType指定该属性的类型</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"student"</span> <span class="attr">id</span>=<span class="string">"studentAndcard"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"sid"</span> <span class="attr">column</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sname"</span> <span class="attr">column</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"cardid"</span> <span class="attr">column</span>=<span class="string">"cardid"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"card"</span> <span class="attr">javaType</span>=<span class="string">"pojo.card"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cardid"</span> <span class="attr">property</span>=<span class="string">"cardid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cardmsg"</span> <span class="attr">property</span>=<span class="string">"cardmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">接口</span><br><span class="line">Student queryStudentAndCardById(int id);</span><br><span class="line">测试</span><br><span class="line">StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student s=StudentMapper.queryStudentAndCardById(1);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>



<h1 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h1><p>只有一种方式，在班级类里增加学生属性<br>因为是一对多，所以是list<student></p>
<p>班级类和学生类<br>班级类<br>classid classname<br>学生类<br>sid sname classid</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">class student&#123;</span><br><span class="line">    int sid;</span><br><span class="line">    String sname;</span><br><span class="line">    int classid;</span><br><span class="line">&#125;</span><br><span class="line">class classes&#123;</span><br><span class="line">    int classid;</span><br><span class="line">    String classname;</span><br><span class="line"></span><br><span class="line">    List<span class="tag">&lt;<span class="name">Student</span>&gt;</span> students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"querytogetstudents"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"classes_students"</span>&gt;</span></span><br><span class="line">select * from classes,student where classes.classid=student.classid and classid=#&#123;classid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"classes"</span> <span class="attr">id</span>=<span class="string">"classes_students"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"classid"</span> <span class="attr">column</span>=<span class="string">"classid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"classname"</span> <span class="attr">column</span>=<span class="string">"classname"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//描述该属性的类型是javaType  描述该属性 里面的元素的类型 是ofType</span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"pojo.student"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"sid"</span> <span class="attr">property</span>=<span class="string">"sid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sname"</span> <span class="attr">property</span>=<span class="string">"sname"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>






<h1 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h1><p>resultMap 一对一问题/类型不一致问题</p>
<p>一对多==多对一<br>要先了解数据库里 什么是一对多/多对一<br>学生 学号 老师 班级<br>学生和学号是一对一<br>学生和班级是多对一<br>学生和老师是多对多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int id;</span><br><span class="line">    int tid;</span><br><span class="line">    Teacher teacher;//学生里面有一个老师</span><br><span class="line">&#125;</span><br><span class="line">class Teacher&#123;</span><br><span class="line">    int tid;</span><br><span class="line">    String tname;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我要查询学生以及对应的老师<br>select s.id,s.name,t.name from student s,teacher t where t.tid=s.id;</p>
<p>student的teacher属性查出的结果会是null</p>
<h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><p>目的：我要查询所有student<br>问题：student对象中有teacher属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from teacher where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单个的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--复杂的属性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对象用association--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置封装Teacher  column是 用哪个字段来获取对象   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"tid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tname"</span> <span class="attr">property</span>=<span class="string">"tname"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from teacher where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查出来的是一个叫StudentTeacher的东西，其中的单个属性类型用result  其中的对象类型用association（association的作用就是组成一个对象类型）</p>
<h1 id="日志的使用"><a href="#日志的使用" class="headerlink" title="日志的使用"></a>日志的使用</h1><p>使用mapper映射 我们如何输出sql日志？<br>日志的作用是排错。<br>排错之前使用的是sout,debug<br>现在我们使用日志工厂</p>
<p>两种日志:</p>
<ul>
<li>LOG4J</li>
<li>STDOUT_LOGGING 标准日志输出</li>
</ul>
<h2 id="1-标准日志输出"><a href="#1-标准日志输出" class="headerlink" title="1.标准日志输出"></a>1.标准日志输出</h2><p>mybatis_congfig.xml添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-LOG4J日志"><a href="#2-LOG4J日志" class="headerlink" title="2.LOG4J日志"></a>2.LOG4J日志</h2><p>使用LOG4J需要导包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在resource下新建log4j.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># priority  :debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">#you cannot specify every priority with different file for log4j</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug,stdout,info,debug,warn,error </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#console</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender </span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>= <span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n</span></span><br><span class="line"><span class="comment">#info log</span></span><br><span class="line"><span class="meta">log4j.logger.info</span>=<span class="string">info</span></span><br><span class="line"><span class="meta">log4j.appender.info</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.info.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.info.File</span>=<span class="string">./log/info.log</span></span><br><span class="line"><span class="meta">log4j.appender.info.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.info.Threshold</span>=<span class="string">INFO</span></span><br><span class="line"><span class="meta">log4j.appender.info.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.info.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br><span class="line"><span class="comment">#debug log</span></span><br><span class="line"><span class="meta">log4j.logger.debug</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">log4j.appender.debug</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.debug.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.debug.File</span>=<span class="string">./src/com/hp/log/debug.log</span></span><br><span class="line"><span class="meta">log4j.appender.debug.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.debug.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.debug.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.debug.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br><span class="line"><span class="comment">#warn log</span></span><br><span class="line"><span class="meta">log4j.logger.warn</span>=<span class="string">warn</span></span><br><span class="line"><span class="meta">log4j.appender.warn</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.warn.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.warn.File</span>=<span class="string">./src/com/hp/log/warn.log</span></span><br><span class="line"><span class="meta">log4j.appender.warn.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.warn.Threshold</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">log4j.appender.warn.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.warn.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br><span class="line"><span class="comment">#error</span></span><br><span class="line"><span class="meta">log4j.logger.error</span>=<span class="string">error</span></span><br><span class="line"><span class="meta">log4j.appender.error</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.error.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.error.File</span> = <span class="string">./src/com/hp/log/error.log </span></span><br><span class="line"><span class="meta">log4j.appender.error.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.error.Threshold</span> = <span class="string">ERROR </span></span><br><span class="line"><span class="meta">log4j.appender.error.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.error.layout.ConversionPattern</span> = <span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br></pre></td></tr></table></figure>

<p>mybatis_congfig.xml添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>log4j的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">Logger logger=Logger.getLogger(Test4<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">logger.info(<span class="string">"测试info"</span>);</span><br><span class="line">logger.debug(<span class="string">"测试debug"</span>);</span><br><span class="line">logger.error(<span class="string">"测试error"</span>);</span><br></pre></td></tr></table></figure>



<h1 id="实现分页"><a href="#实现分页" class="headerlink" title="实现分页"></a>实现分页</h1><p>为什么要分页<br>减少每次处理的数据</p>
<p>实现方式<br>1.limit</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> startIndex,pageSize;</span><br></pre></td></tr></table></figure>
<p>pageSize=-1 是直到最后一个元素（现在不可用）</p>
<p>2.mybatis实现</p>
<h1 id="mybatis缓存"><a href="#mybatis缓存" class="headerlink" title="mybatis缓存"></a>mybatis缓存</h1><p>一级缓存   sqlsession级别 默认开启</p>
<p>如果执行了insert/update/delete的sql语句，缓存必须清空</p>
<p>二级缓存 mapper级别  默认关闭<br>打开时，多个sqlsession使用同一个mapper的sql语句执行<br>得到的数据存在二级缓存区（使用hashmap进行存储）<br>跨sqlsession的，作用域是mapper的同一个namespace</p>
<p>1.修改mybatis_config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnable"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.在mapper.xml中配置二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.对应的实体类实现序列化接口</p>
<h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><h2 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h2><p>程序根据业务参数来决定SQL的组成</p>
<h2 id="在什么情况下："><a href="#在什么情况下：" class="headerlink" title="在什么情况下："></a>在什么情况下：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id=""&gt;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="comment">#&#123;&#125; and userid=#&#123;&#125; and password=#&#123;&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们输入的 userid为空，我们希望这个语句也能查出结果<br>所有需要添加if-else条件判断语句</p>
<h2 id="怎么做："><a href="#怎么做：" class="headerlink" title="怎么做："></a>怎么做：</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">select * from user where </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span>username=#&#123;username&#125; and<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userid!=0"</span>&gt;</span>userid=#&#123;userid&#125; and<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password!=null"</span>&gt;</span>password=#&#123;password&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这么做的缺点   and不好处理<br>2.需要<where>标签  where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">select * from user where </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span>username=#&#123;username&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userid!=0"</span>&gt;</span>and userid=#&#123;userid&#125; and<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password!=null"</span>&gt;</span>and password=#&#123;password&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3.choose和when标签<br>相当于switch case break（满足第一个when后，后面的语句不会执行）</p>
<p>4.trim标签<br>prefix和suffix属性 会用于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>set标签  用于update操作<br>取消不用修改的多余字段的update</p>
<p>5.foreach标签<br>用于in语句<br>select * from user where userid in (1,2,3)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIds"</span>&gt;</span></span><br><span class="line">    select * from user </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"id in ("</span>  <span class="attr">close</span>=<span class="string">")"</span>  <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h1 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h1><p>mybatis-spring包</p>
]]></content>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/tantian123.github.io/2020/05/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h1><p>为什么需要代理类？<br>对既有代码不改动的情况下进行功能的扩展<br>例如：Aop </p>
<p>代理模式的实现方式：动态代理，静态代理</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>例子<br>    实现Runnble接口<br>缺点<br>    1.代理类和被代理类都是在编译期间被确定了，不利于扩展<br>    2.每个代理类只能为一个/一套接口服务，那么整个程序会有很多代理类，冗余</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要求：1.代理类和被代理实现同一个接口</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">动态代理</span><br><span class="line">是反射的应用</span><br><span class="line"></span><br><span class="line">动态代理的应用：调试，远程方法调用</span><br><span class="line">优缺点：</span><br><span class="line">优点：解决静态代理的缺点， 在程序运行时动态创建被代理类的代理对象</span><br><span class="line"></span><br><span class="line">动态代理的实现  两种方式 jdk动态代理/cglib</span><br><span class="line">jdk动态代理只能对接口做代理  /cglib是框架 通过asm字节码技术</span><br><span class="line">jdk动态代理 两个步骤： </span><br><span class="line"><span class="number">1</span>.根据加载到内存的被代理类，动态创建代理类对象  使用java.lang.reflect.Proxy类，通过Proxy.newProxyInstance()方法实现</span><br><span class="line"></span><br><span class="line">创建了一个动态代理对象</span><br><span class="line"><span class="number">2</span>.代理类对象 调用方法a时，如何能去调用被代理类的a方法,InvocationHandler接口及其invoke方法</span><br><span class="line"></span><br><span class="line">使用InvocationHandler调用方法</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Object类常用方法</title>
    <url>/tantian123.github.io/2020/05/27/Object%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h1><p>获得运行时类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h1><p>Returns a hash code value for the object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>
<p>两个对象相同，它们的hashcode值一定要相同<br>两个对象不同，它们的hashcode值可能相同也可能不同<br>重写equals()就一定要重写hashCode()</p>
<h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span> == obj;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>只不过，String类重写了equals方法</p>
<h1 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h1><p>实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法<br>具体的实现是有C/C++完成的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h1><p>注意 char数组没有toString()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我门system.out.print(obj)时，其实调用了tostring</p>
<h1 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h1><p>该方法唤醒在该对象上等待的某个线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void notify();</span><br></pre></td></tr></table></figure>
<h1 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h1><p>该方法唤醒在该对象上等待的所有线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void notifyAll();</span><br></pre></td></tr></table></figure>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>
<h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h1><h1 id="重写equals-方法就必须重写hashCode-方法"><a href="#重写equals-方法就必须重写hashCode-方法" class="headerlink" title="重写equals()方法就必须重写hashCode()方法"></a>重写equals()方法就必须重写hashCode()方法</h1><p>针对HashSet和Map集合类型<br>如果只重写了equals()方法，没有重写hashCode()<br>那么两个相同属性的对象，因为hashcode不同，所以能同时存在于集合中。</p>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/tantian123.github.io/2020/05/26/java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>反射的概念<br>小写是关键字 大写是类</li>
</ul>
<p>class类的常用方法<br>classforname<br>newinstance<br>getclassloader<br>getconstruction<br>getmethod<br>getDeclaredFields</p>
<ul>
<li>原理<br>  优缺点  灵活 性能低了</li>
<li>应用<br>  反射相关的类</li>
</ul>
<h1 id="获取class类"><a href="#获取class类" class="headerlink" title="获取class类"></a>获取class类</h1><p>1.调用类的.class属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1=String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
<p>2.通过对象获取  getClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">Class c1=p.getClass();</span><br></pre></td></tr></table></figure>
<p>3.通过Class的静态方法 forName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1=Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p>4.通过类的加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader cl=<span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class c1=cl.loadClass(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p>2.通过基本数据类型的TYPE属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span></span>=Integer.TYPE;</span><br></pre></td></tr></table></figure>
<p>获取父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c2=c1.getSuperClass();</span><br></pre></td></tr></table></figure>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>1.将class字节码文件读入内存，<br>2.将这些静态数据转换为方法区的运行时数据结构<br>3.生成唯一的一个代表这个类的java.lang.Class对象，接下来所有对该类的访问都通过这个对象<br>以上通过类的加载器实现</p>
<h2 id="类的链接（验证-准备-解析）"><a href="#类的链接（验证-准备-解析）" class="headerlink" title="类的链接（验证 准备 解析）"></a>类的链接（验证 准备 解析）</h2><p>1.验证 保证二进制字节流中的信息符合虚拟机规范，并没有安全问题（例如java数组不能越界访问）<br>2.准备  (1)为已经在方法区中的类中的静态成员变量分配内存 (2)为静态成员变量设置初始值 例如0<br>3.解析<br>虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用</p>
<blockquote>
<p>符号引用：hello<br>直接引用：0xaabbccdd</p>
</blockquote>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>1.就是执行类构造器clinit()的过程<br>clinit()是由静态代码块和类变量的赋值语句 合并组成的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class people&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        m=300;</span><br><span class="line">    &#125;</span><br><span class="line">    static int m=100;</span><br><span class="line">&#125;</span><br><span class="line">合并后</span><br><span class="line">clinit()&#123;</span><br><span class="line">     m=300;</span><br><span class="line">     m=100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类构造器是构造类的信息的 clinit=class init</p>
</blockquote>
<p>2.当初始化一个类时，先检查父类是否初始化，否则先初始化父类<br>3.虚拟机会保证一个类的clinit()方法在多线程中被正确加锁和同步</p>
<h2 id="什么时候进行类初始化"><a href="#什么时候进行类初始化" class="headerlink" title="什么时候进行类初始化"></a>什么时候进行类初始化</h2><p>类的主动引用，类初始化<br>类的被动引用，不会类初始化</p>
<p>主动引用</p>
<ul>
<li>虚拟机启动，初始化main</li>
<li>new一个类的对象</li>
<li>调用类的静态方法和静态成员</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>初始化一个类，如果它的父类没有初始化，就会先初始化父类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//输出main</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.主动引用</span></span><br><span class="line">        <span class="comment">//new</span></span><br><span class="line">        Son s=<span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//反射</span></span><br><span class="line">        Class.forName(<span class="string">"com.tt.test.son"</span>);</span><br><span class="line">        <span class="comment">//2.被动引用</span></span><br><span class="line">        System.out.println(Son.a);<span class="comment">//子类不被加载，虽然是通过子类调用的</span></span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        Son[] sonArray=<span class="keyword">new</span> Son[<span class="number">5</span>];<span class="comment">//只有main类被加载。数组只占空间</span></span><br><span class="line">        <span class="comment">//引用常量</span></span><br><span class="line">        System.out.println(Son.N);<span class="comment">//只有main类被加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//输出father</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//输出son</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>被动引用</p>
<ul>
<li>访问静态域，只有真正声明这个域的类会被初始化，其它类引用的不算（通过子类引用父类的静态变量，不会导致子类初始化，其实根本不关子类的事）</li>
<li>数组定义类引用，不会触发此类初始化（数组只占空间）</li>
<li>引用常量（常量在常量池里,链接阶段就存入了）</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>作用：</p>
<p>类缓存：一旦类被加载到类加载器中，会被维持一段时间，GC回收这些class对象</p>
<p>类加载器：<br>1.引导类加载器 Bootstap ClassLoader<br>c++编写,负责加载核心库<br>2.扩展类加载器 Extension ClassLoader<br>负责jre/lib/ext下的jar包<br>3.系统类加载器 System ClassLoader<br>负责classpath下的类与jar包</p>
<h3 id="如何获取类加载器"><a href="#如何获取类加载器" class="headerlink" title="如何获取类加载器"></a>如何获取类加载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统类加载器</span></span><br><span class="line">ClassLoader systemcl=ClassLoader.getSystemClassLoader；</span><br><span class="line">System.out.println(systemcl.getParent());</span><br><span class="line">System.out.println(systemcl.getParent().getParent());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前类的加载器</span></span><br><span class="line">ClassLoader cl=Class.forName(<span class="string">"java.lang.object"</span>).getClassLoader;</span><br></pre></td></tr></table></figure>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>导致 自己写的java.lang.String无效 的原因</p>
<h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><p>Field Method  Constructor Interface Annotation Superclass<br>java.lang.class<br>java.lang.reflect.Method/Field/Constructor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"xx"</span>);</span><br><span class="line"><span class="comment">//获得类名</span></span><br><span class="line">c.getName();<span class="comment">//获得类名</span></span><br><span class="line"></span><br><span class="line">c.getSimpleName();<span class="comment">//获得包名+类名</span></span><br><span class="line"><span class="comment">//获得类的属性</span></span><br><span class="line">Field[] fields=c.getFields();<span class="comment">//打印public属性</span></span><br><span class="line">Field[] fields=c.getDeclaredFields();<span class="comment">//打印所有属性</span></span><br><span class="line">Field field=c.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//指定属性的值</span></span><br><span class="line"><span class="comment">//获得类的方法</span></span><br><span class="line">c.getMethods();<span class="comment">//获得本类和父类的所有public方法</span></span><br><span class="line">c.getDeclaredMethods();<span class="comment">//获得本类的所有方法（没有父类）</span></span><br><span class="line"></span><br><span class="line">c.getMethod(name,<span class="keyword">null</span>);<span class="comment">//指定方法   null参数指明要不要返回参数（以区别重载）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造器</span></span><br><span class="line">Constructor[] constructors=c.getConstructors();</span><br><span class="line"></span><br><span class="line">c.getDeclaredConstructors(参数<span class="number">1</span><span class="class">.<span class="keyword">class</span>,参数2.<span class="title">class</span> ...)//获得指定的构造器</span></span><br></pre></td></tr></table></figure>

<h2 id="获得class对象之后-创建类的对象-方法-属性"><a href="#获得class对象之后-创建类的对象-方法-属性" class="headerlink" title="获得class对象之后,创建类的对象/方法/属性"></a>获得class对象之后,创建类的对象/方法/属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"xxx.User"</span>);</span><br><span class="line"><span class="comment">//通过反射构造了无参对象</span></span><br><span class="line">User user=(User)c.newInstance();</span><br><span class="line"><span class="comment">//通过构造器创建有参对象</span></span><br><span class="line">Constructor constructor=c.getConstructor(参数<span class="number">1</span><span class="class">.<span class="keyword">class</span>,参数2.<span class="title">class</span> ...)</span>;</span><br><span class="line">User user2=(User)constructor.newInstance(<span class="string">"参数1的值"</span>,<span class="string">"参数2的值"</span>,<span class="string">"参数3的值"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射调用方法</span></span><br><span class="line">User user=(User)c.newInstance();</span><br><span class="line">Method method=c.getDeclaredMethod(<span class="string">"setName"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(user,<span class="string">"tantian"</span>);<span class="comment">//invoke (意思是调用/激活) 参数是：（对象，“方法的值”）</span></span><br><span class="line">System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射操作属性</span></span><br><span class="line">User user=(User)c.newInstance();</span><br><span class="line">Field f=c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f.set(user,<span class="string">"tantian"</span>);</span><br><span class="line"></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);<span class="comment">//关掉private权限检查</span></span><br><span class="line">System.out.println(user.getName());</span><br></pre></td></tr></table></figure>



<h2 id="通过反射获取泛型信息"><a href="#通过反射获取泛型信息" class="headerlink" title="通过反射获取泛型信息"></a>通过反射获取泛型信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Map&lt;Integer,String&gt;)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Method method=Person.class.getMethod("test1",Map.class);</span><br><span class="line">        <span class="comment">//参数类型</span></span><br><span class="line">        Type[] gpt=method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type t:gpt)&#123;</span><br><span class="line">            <span class="comment">//输出了Map&lt;Integer,String&gt;</span></span><br><span class="line">            <span class="comment">//if(是集合) 返回真实类型 代码省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值类型</span></span><br><span class="line">        getGenericReturnTypes()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获取注解信息"><a href="#通过反射获取注解信息" class="headerlink" title="通过反射获取注解信息"></a>通过反射获取注解信息</h2><p>getAnnotations/getAnnotation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">理解动态语言和静态语言</span><br><span class="line">动态语言：运行时改变结构</span><br><span class="line">js，php，python</span><br><span class="line">静态语言</span><br><span class="line">java c c++</span><br><span class="line">java有一定的动态性，利用反射机制获得动态语言的特性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行时注入的概念，例如游戏外挂在程序运行时修改数据</span><br><span class="line">应用：获取注解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反射机制运行程序在执行期间借助Reflection API获取任何类的内部信息（构造器，字段等）</span><br><span class="line">并直接操作任意对象的属性和方法</span><br><span class="line"></span><br><span class="line">Class c=Class.forName(<span class="string">"java.lang.String"</span>)</span><br><span class="line"></span><br><span class="line">在堆的方法区产生了<span class="class"><span class="keyword">class</span>类型对象 ，包含了类的完整的结构信息</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">通过反射创建对象-&gt;<span class="title">getclass</span>-&gt; 获得类的完整包名</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">功能：运行时判断对象所属的类/成员变量/方法</span></span><br><span class="line"><span class="class">运行时构造类的对象</span></span><br><span class="line"><span class="class">生成动态代理</span></span><br><span class="line"><span class="class">运行时处理注解</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Class</span>有一个静态方法<span class="title">forname</span> 获得<span class="title">Class</span>对象</span></span><br><span class="line"><span class="class">使用方式</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">c</span></span>=Class.forName(<span class="string">"包里的类路径"</span>)</span><br><span class="line"></span><br><span class="line">一个<span class="class"><span class="keyword">class</span>只有一个对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">获取<span class="title">class</span>类的实例的方式</span></span><br><span class="line"><span class="class"><span class="title">person</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">getClass</span></span></span><br><span class="line"><span class="class"><span class="title">Class</span>.<span class="title">forName</span></span></span><br><span class="line"><span class="class"><span class="title">classloader</span></span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java注解</title>
    <url>/tantian123.github.io/2020/05/26/java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>注解的基本概念<ul>
<li>注解的格式</li>
<li>注解类型<ul>
<li>元注解 注解其他注解</li>
<li>内置注解</li>
<li>自定义注解</li>
</ul>
</li>
</ul>
</li>
<li>注解的原理</li>
<li>注解的应用场景<ul>
<li>编译检查</li>
<li>在反射中使用 </li>
</ul>
</li>
</ul>
<h1 id="1-注解的基本概念"><a href="#1-注解的基本概念" class="headerlink" title="1.注解的基本概念"></a>1.注解的基本概念</h1><p>Annotation注解<br>可以把注解理解为代码里的特殊标记，这些标记可以<strong>在编译，类加载，运行时</strong>被读取，并执行相应的处理。通过注解开发人员可以在<strong>不改变原有代码和逻辑</strong>的情况下在源代码中嵌入补充信息。<br>说人话就是，不是程序本身，对程序起解释作用，可以被编译器读取。</p>
<h2 id="1-1注解的格式"><a href="#1-1注解的格式" class="headerlink" title="1.1注解的格式"></a>1.1注解的格式</h2><p>在需要注解的地方的上一行 加上 @注解名 就可以了<br><strong>可以用在于类，构造函数和字段的声明处</strong><br>即package，class，method，field上面</p>
<h2 id="1-2注解类型"><a href="#1-2注解类型" class="headerlink" title="1.2注解类型"></a>1.2注解类型</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>基本注解，能注解其它注解,在java.lang.annotation下<br>有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。<br>@Retention 描述注解存在的阶段（编译期/类加载时/运行时）<br>@Documented 能够将注解中的元素包含到 Javadoc 中去<br>@Target  用于描述注解的使用范围（类，方法，方法参数变量等）<br>@Inherited 该注解修饰的父类，能被子类继承注解（如果子类没有注解的话）<br>@Repeatable 这个元注解修饰的注解可以同时作用一个对象多次，每次的作用可能不同</p>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>@Override 提示子类必须重写父类方法<br>@SuppressWarnings 阻止编译器警告<br>@Deprecated  用来标记过时的元素 编译器会识别并提醒程序员<br>@SafeVarargs 安全参数<br>@FunctionalInterface JDK1.8引入的 函数式接口注解，例如Runnable 就是一个典型的函数式接口，可以转换为Lambda表达式。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>1.自定义注解的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2.注解还可以添加属性，属性也可以叫成员变量<br>属性的类别可以是8种基本数据类型外加 <strong>类、接口、注解及它们的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    <span class="comment">//这个注解中拥有 id 和 msg 两个属性，在使用的时候，我们可以赋值。</span></span><br><span class="line">    <span class="comment">//参数类型+参数名+()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">@注解名(id=<span class="number">1</span>,msg=<span class="string">"hello world"</span>)<span class="comment">//如果只有一个属性，可以去掉键</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>3.注解可以有默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; </span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "not good"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-注解的原理-目的"><a href="#2-注解的原理-目的" class="headerlink" title="2.注解的原理/目的"></a>2.注解的原理/目的</h1><p>获取属性的值才是使用注解的目的，使用反射的方式（java.lang.reflect.AnnotationElement接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子 通过反射获取注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyField &#123;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用我们的自定义注解</span></span><br><span class="line">    <span class="meta">@MyField</span>(description = <span class="string">"用户名"</span>, length = <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyField</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类模板</span></span><br><span class="line">        Class c = MyFieldTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有字段</span></span><br><span class="line">        <span class="keyword">for</span>(Field f : c.getDeclaredFields())&#123;</span><br><span class="line">            <span class="comment">// 判断这个字段是否有MyField注解</span></span><br><span class="line">            <span class="keyword">if</span>(f.isAnnotationPresent(MyField<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                MyField annotation = f.getAnnotation(MyField<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"字段:["</span> + f.getName() + <span class="string">"], 描述:["</span> + annotation.description() + <span class="string">"], 长度:["</span> + annotation.length() +<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解本身就是Annotation接口的子接口</p>
<h1 id="3-注解的应用场景"><a href="#3-注解的应用场景" class="headerlink" title="3.注解的应用场景"></a>3.注解的应用场景</h1><h2 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h2><p>提供信息给编译器</p>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2>]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的排序算法</title>
    <url>/tantian123.github.io/2020/05/21/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>从左到右遍历，每次比较相邻的两个元素，将大的放到右边<br>每次排序，都会选出当前最大的元素，放在最后<br>一直重复，直到选完。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a=new int[n];</span><br><span class="line"></span><br><span class="line">for(int l=n-1;l&gt;0;l--)</span><br><span class="line">    for(int i=0;i&lt;l;i++)</span><br><span class="line">        if(a[i]&gt;a[i+1]) swap(i,i+1);</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>从左到右遍历，每次比较所有元素，保存一个max值<br>每次排序，都会选出当前最大的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxindex;</span><br><span class="line">int[] a=new int[n];</span><br><span class="line">for(int l=n-1;l&gt;=0;l--)&#123;</span><br><span class="line">    for(int i=0;i&lt;l;i++)&#123;</span><br><span class="line">        if(a[maxindex]&lt;a[i])&#123;</span><br><span class="line">            a[maxindex]=a[i];</span><br><span class="line">            maxindex=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(l,maxindex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>分为有序区和无序区  [0<del>i] [i+1</del>n-1]<br>假设第一个元素已被排好序，是有序区的第一个元素<br>从无序区第一个元素开始，从后往前遍历无序区<br>每次，遍历有序区，找到插入的位置，<br>将元素插入（从后往前，每次和前面的元素交换，直到发现比自己小的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">    index=i;</span><br><span class="line">    while(a[index]&gt;a[index-1]&amp;&amp;index&gt;0)&#123;</span><br><span class="line">        swap(a[index],a[index-1]);</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>它以插入排序为基础，将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序(每间隔为i的所有元素选出来组成子列表，然后对每个子序列进行插入排序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>递归<br>基准数（这里我们取第一个）</p>
<p>遍历 将小于基准的放在左边，大于基准的放在右边（使用双指针）<br>然后递归 对基准左边的做一次快排  对基准右边的做一次快排</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">quickSort(0,n-1);</span><br><span class="line"></span><br><span class="line">void quickSort(l,r)&#123;</span><br><span class="line">    int pivot=a[l];//随机选基准</span><br><span class="line">    </span><br><span class="line">    int i=l,j=r;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        while(a[j]&gt;pivot&amp;&amp;i&lt;j) j--;</span><br><span class="line">        while(a[i]&lt;pivot&amp;&amp;i&lt;j) i++;</span><br><span class="line">        swap(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    //最后把基准放到中间</span><br><span class="line">    //j先动，所以最后是i和基准交换</span><br><span class="line">    a[l]=a[i];</span><br><span class="line">    a[i]=pivot;</span><br><span class="line">    </span><br><span class="line">    quickSort(l,pivot-1);</span><br><span class="line">    quickSort(pivot+1,r);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治  先分再治</p>
<ul>
<li>把列表分为两部分，如果列表长度小于等于1，则被排序完成</li>
<li>两部分都排好序后，就进行合并子序列<br>（具体操作：申请一个同样大小的数组，使用两个指针，比较两个指针的数，将更小的数加入新数组，并移动指针，直到有一边的指针出界 之后再将没出界那边的数依次填入新数组）</li>
</ul>
<p>有两种实现，自顶向下 自底向上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mergeSort(0,n-1);</span><br><span class="line"></span><br><span class="line">void mergeSort(l,r)&#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    </span><br><span class="line">    int mid=l+(r-l)/2;</span><br><span class="line">    mergeSort(l,mid);</span><br><span class="line">    mergeSort(mid+1,r);</span><br><span class="line">    merge(l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(l,mid,r)&#123;</span><br><span class="line">    int i=l,j=mid+1;//这里要注意 j=mid+1;</span><br><span class="line">    int[] a2=new int[r-l+1];</span><br><span class="line">    int flag=l;//新数组起始点指针</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        if(a[i]&gt;a[j])&#123;</span><br><span class="line">            a2[flag]==a[j];</span><br><span class="line">            j++;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            a2[flag]==a[i];</span><br><span class="line">            i++;</span><br><span class="line">            flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //把仅剩的元素填入a2</span><br><span class="line">    while(i&lt;=mid) &#123;a2[flag]=a[i];i++&#125;</span><br><span class="line">    while(j&lt;=r) &#123;a2[flag]=a[j];j++&#125;</span><br><span class="line">    </span><br><span class="line">    a = Arrays.copyOfRange(a2, l,r);//复制回去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>选择排序<br>堆是一个完全二叉树，具有以下性质<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆（不要和二叉排序树弄混了）</p>
<p>两种建堆的过程：<br>一种是直接使用原数组，另一种是不断插入</p>
<ul>
<li>1.直接在原数组上改，从A.length/2一直到根结点进行Heapify调整  时间复杂度O(n)</li>
<li>2.假定我们事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。<br>先插入（保持完全二叉树），再heapify，重复<br>时间复杂度O(nlogn)</li>
</ul>
<p><a href="https://visualgo.net/zh/heap" target="_blank" rel="noopener">动画网站</a></p>
<p>整体的步骤：</p>
<ul>
<li>将无需序列构建成一个堆(buildHeap)，根据升序降序需求选择大顶堆或小顶堆</li>
<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端（这个元素就不要管了）</li>
<li>重新调整结构，使其满足堆定义(heapify)，然后继续交换堆顶元素与当前末尾元素，反复执行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a=new int[n];</span><br><span class="line">void heapify(int[] a,int i,int n)&#123;</span><br><span class="line">    //递归出口</span><br><span class="line">    if(i&gt;=n) return;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    int child1=2i+1;</span><br><span class="line">    int child2=2i+2;</span><br><span class="line">    int maxindex=i;</span><br><span class="line">    if(child1&lt;n&amp;&amp;a[child1]&gt;a[i])</span><br><span class="line">        maxindex=child1;</span><br><span class="line">    if(child2&lt;n&amp;&amp;a[child2]&gt;a[i])</span><br><span class="line">        maxindex=child2;</span><br><span class="line">    </span><br><span class="line">    if(maxindex!=i)&#123;</span><br><span class="line">        temp=a[maxindex];</span><br><span class="line">        a[maxindex]=a[i];</span><br><span class="line">        a[i]=temp;</span><br><span class="line">        </span><br><span class="line">        heapify(a,maxindex);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void build_heap(int[] a)&#123;</span><br><span class="line">    int last_node=a.length-1;</span><br><span class="line">    int parent=last_node-1/2;</span><br><span class="line">    for(int i=parent,i&gt;=0;i--)&#123;</span><br><span class="line">        heapify(a,i,a.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序的基本思想是将一个数据表分割成许多buckets，然后每个bucket各自排序，或用不同的排序算法，或者递归的使用bucket sort算法</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序其实是桶排序的一种特殊情况。<br>比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较<br>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>比如比较电话号码</p>
<h3 id="评价一个排序算法"><a href="#评价一个排序算法" class="headerlink" title="评价一个排序算法"></a>评价一个排序算法</h3><p>三个方面：<br>执行效率、内存消耗、稳定性<br>1.时间复杂度</p>
<p>2.稳定  不稳定<br>相等的两个元素 经过排序后，原有的顺序不变</p>
<p>3.内排序 外排序 原地排序<br>排序操作在内存<br>数据大太，所以放在磁盘，所以排序需要通过磁盘和内存进行数据传输<br>空间复杂度O(1)的排序</p>
<p><img src="/images/sort.jpg" alt="image"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java String类</title>
    <url>/tantian123.github.io/2020/05/21/java-String%E7%B1%BB/</url>
    <content><![CDATA[<p>定义在 java.lang包下</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul>
<li>new方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s=new String();</span><br><span class="line">``` </span><br><span class="line">JVM创建字符串对象，但不存储在字符串常量池</span><br></pre></td></tr></table></figure>
String(char[] value)<br>String(char chars[], int x, int n)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 双引号</span><br></pre></td></tr></table></figure>
String s=”hello”;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM去字符串池找有没有值相等字符串，如果有，则返回找到的字符串引用。否则创建一个新的字符串对象并存储在字符串池</span><br><span class="line"></span><br><span class="line">对象转为字符串toString方法</span><br><span class="line">toString是Object类定义的</span><br><span class="line"></span><br><span class="line"># 常用方法</span><br></pre></td></tr></table></figure>
public int length()</li>
</ul>
<p>public char charAt(int index)</p>
<p>public String substring(int beginIndex)<br>public String substring(int beginIndex, intendIndex)</p>
<p>public int compareTo(String str)</p>
<p>public char[] toCharArray()</p>
<p>public int indexOf(String str)</p>
<p>public String toLowerCase()<br>public String toUpperCase()</p>
<p>String trim()</p>
<p>String[] split(String str)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 属性</span><br><span class="line"></span><br><span class="line"># ==和equals的区别</span><br><span class="line">+ == </span><br><span class="line">对于基本数据类型，比较值</span><br><span class="line">对于引用类型，比较内存地址</span><br><span class="line">+ equals</span><br><span class="line">equals不能比较基本数据类型（它是继承Object类）</span><br><span class="line">如果没对equals进行重写，它比较地址</span><br><span class="line">但是，String/Date类进行了重写，所以只比较值。</span><br><span class="line"></span><br><span class="line"># +号 拼接</span><br><span class="line">因为String是immutable的，每次的操作都会创建一个新的String对象（非常耗时）</span><br><span class="line">字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象</span><br><span class="line"></span><br><span class="line">所以字符串+操作的时候，用StringBuilder更快</span><br><span class="line"># String StringBuilder和StringBuffer</span><br><span class="line">StringBuilder</span><br><span class="line">StringBuffer</span><br></pre></td></tr></table></figure>
<p>StringBuffer 对象.append(String str)</p>
<p>StringBuffer 对象.reverse();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">区别：StringBuffer是线程安全的（synchronized），而 StringBuilder不是，所以StringBuilder效率更高，锁的获取和释放会带来开销。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实，stringbuffer基本没有适用场景，你应该在所有的情况下选择使用stringbuiler</span><br><span class="line"># intern方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 面试题：</span><br><span class="line">1.String是基本数据类型吗</span><br><span class="line">不是，基本数据类型是 byte short int long char double float boolean</span><br><span class="line">2.String可以被继承吗</span><br><span class="line">不能，是final类</span><br><span class="line">3.String有reverse方法吗</span><br><span class="line">String没有，但StringBuffer和StringBuilder有</span><br><span class="line">4.String, StringBuffer，StringBuilder的区别</span><br><span class="line">5.String是不可变的有什么好处</span><br><span class="line">线程安全 运行时节省大量java堆空间</span><br><span class="line">6.如何判断两个String是否相等</span><br><span class="line"> &quot; == &quot;或者equals</span><br><span class="line">equals是判断两个变量或实例所指向的内存空间的值是不是相同(比较变量的值)</span><br><span class="line">使用&quot;==&quot;操作符时，不仅比较字符串的值，还会比较引用的内存地址(比较内存地址)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.</span><br></pre></td></tr></table></figure>
<p>String a = “hello2”;String b = “hello” + 2;System.out.println((a == b));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出是true</span><br><span class="line">&quot;hello&quot;+2在编译期间就已经被优化成&quot;hello2&quot;，因此在运行期间，变量a和变量b指向的是同一个对象。</span><br></pre></td></tr></table></figure>
<p>String a = “hello2”;String b = “hello”;String c = b + 2;System.out.println((a == c));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果为：false</span><br><span class="line">由于有符号引用的存在，所以 String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象</span><br></pre></td></tr></table></figure>
<p> //str1 += “love”+”java”;        //代码1<br> str1 = str1+”love”+”java”;      //代码2 </p>
<pre><code>代码1的效率比代码2的效率要高，代码1中的&quot;love&quot;+&quot;java&quot;在编译期间会被优化成&quot;lovejava&quot;，而代码2中的不会被优化。
7.讲一下字符串常量池</code></pre>]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合</title>
    <url>/tantian123.github.io/2020/05/21/java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="常见的集合类"><a href="#常见的集合类" class="headerlink" title="常见的集合类"></a>常见的集合类</h1><p>Map和Collection接口</p>
<p>Collection接口的子接口有，Set接口，List接口,Queue接口<br>Map接口有 HashMap TreeMap LinkedHashMap CorrentHashMap HashTable</p>
<p>Set接口有 HashSet TreeSet LinkedHashSet CorrentHashSet<br>List接口有 LinkedList ArrayList Vector<br>Queue接口有 PriorityQueue LinkedList dequeue</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Map存的是键值对，键是唯一的<br>List存的是可重复的<br>Set是不可重复的</p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>LinkedList 基于链表<br>ArrayList 基于数组，线程不安全<br>Vector 线程安全</p>
<p>数组和链表的关键区别：内存连不连续</p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>散列表(数组+链表)   当链表长度大于阈值时，转化为红黑树</p>
<h3 id="Hashtable-线程安全"><a href="#Hashtable-线程安全" class="headerlink" title="Hashtable  线程安全"></a>Hashtable  线程安全</h3><p>底层散列表</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>底层是红黑树</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>底层是散列表和双向链表<br>HashMap中不存在保存顺序，LinkedHashMap专为此特性而生</p>
<h3 id="ConcurrentHashMap-线程安全"><a href="#ConcurrentHashMap-线程安全" class="headerlink" title="ConcurrentHashMap 线程安全"></a>ConcurrentHashMap 线程安全</h3><p>jdk1.8 散列表+红黑树         synchronized只锁定当前链表或红黑二叉树的首节点（因为是链地址法解决冲突）<br>jdk1.7 segments（继承ReetrantLock）+HashEntry数组</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h3 id="HashSet-LinkedHashSet"><a href="#HashSet-LinkedHashSet" class="headerlink" title="HashSet/LinkedHashSet"></a>HashSet/LinkedHashSet</h3><p>基于HashMap/LinkedHashMap</p>
<p>1.Array和ArrayList的区别<br>Array定长，ArrayList 的大小是动态变化的<br>可以包含基本类型和对象类型，ArrayList 只能包含对象类型</p>
<p>2.哪些集合可以存放null？<br>上述集合除了Hashtable和ConcurrentHashMap都可以。</p>
<p>Collection和Collections的区别：<br>Java..util.Collection是一个接口<br>Collections则是集合类的一个工具类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索及线程安全等操作。</p>
<p>3.散列表冲突的解决?<br>开放地址法 寻找下一个空的数组下标<br>再散列法(二次哈希法)  再计算一次<br>链地址法(拉链法)   链表存</p>
]]></content>
      <tags>
        <tag>面向面试编程</tag>
        <tag>java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>http总结</title>
    <url>/tantian123.github.io/2020/05/20/http%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP (超文本传输协议)"></a>HTTP (超文本传输协议)</h1><p>定义了 浏览器如何向万维网服务器请求万维网文档,以及服务器如何将文档传给浏览器</p>
<p>HTTP使用TCP，而不是UDP作为它的运输层协议。因此不用担心数据丢失，TCP作为一层抽象屏蔽了底层的细节，HTTP不用管数据的传输。</p>
<h2 id="HTTP是无状态协议"><a href="#HTTP是无状态协议" class="headerlink" title="HTTP是无状态协议"></a>HTTP是无状态协议</h2><p>服务器不保存任何客户端的信息。<br>当我们要保存登录状态的时候，必须使用cookie<br>cookie在请求和响应报文中写入</p>
<h2 id="长连接-短连接"><a href="#长连接-短连接" class="headerlink" title="长连接/短连接"></a>长连接/短连接</h2><p>持久连接（长连接） HTTP默认方式<br>所有请求及响应 经由相同的TCP连接<br>非持久连接（短连接）<br>所有请求及响应 经由分别的TCP连接</p>
<p>优缺点：<br>短连接必须为每个请求 维护一个新的连接，每个这样的连接，都要分配TCP的缓冲区和变量</p>
<h1 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h1><h2 id="1-HTTP请求报文"><a href="#1-HTTP请求报文" class="headerlink" title="1.HTTP请求报文"></a>1.HTTP请求报文</h2><p>line(status line/header line/null line)+body<br>先看图：<br><img src="/images/http.jpg" alt="http"></p>
<p>第一行叫做请求行，后面的叫做首部行</p>
<h3 id="1-1-请求行有"><a href="#1-1-请求行有" class="headerlink" title="1.1 请求行有"></a>1.1 请求行有</h3><p>三个字段：方法字段+URL字段+HTTP协议版本字段</p>
<ul>
<li>方法字段：GET POST HEAD PUT DELETE</li>
<li>URL字段：对象的URL地址(不包括域名)</li>
<li>HTTP协议版本字段<h3 id="1-2-首部行（请求头）"><a href="#1-2-首部行（请求头）" class="headerlink" title="1.2 首部行（请求头）"></a>1.2 首部行（请求头）</h3>由关键字/值对组成，每行一对</li>
</ul>
<p>User-Agent : 产生请求的浏览器类型<br>Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型<br>Content-Type：发送端发送的实体数据的数据类型。<br>比如，Content-Type：text/html（application/json）表示发送的是html类型。<br>Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</p>
<h3 id="1-3空行-用来通知服务器以下不存在请求头了"><a href="#1-3空行-用来通知服务器以下不存在请求头了" class="headerlink" title="1.3空行 用来通知服务器以下不存在请求头了"></a>1.3空行 用来通知服务器以下不存在请求头了</h3><h3 id="1-4请求体（不一定有）"><a href="#1-4请求体（不一定有）" class="headerlink" title="1.4请求体（不一定有）"></a>1.4请求体（不一定有）</h3><p>GET没有，POST有</p>
<h2 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h2><h3 id="2-1状态行"><a href="#2-1状态行" class="headerlink" title="2.1状态行"></a>2.1状态行</h3><p>三个字段：服务器HTTP协议版本，响应状态码，状态码的文本描述</p>
<ul>
<li>服务器HTTP协议版本</li>
<li>状态码 例如200</li>
<li>状态码的文本描述 例如OK </li>
</ul>
<h3 id="2-2首部行（消息报头）"><a href="#2-2首部行（消息报头）" class="headerlink" title="2.2首部行（消息报头）"></a>2.2首部行（消息报头）</h3><h3 id="2-3空行"><a href="#2-3空行" class="headerlink" title="2.3空行"></a>2.3空行</h3><h3 id="2-4响应体"><a href="#2-4响应体" class="headerlink" title="2.4响应体"></a>2.4响应体</h3><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>由3位数字组成，第一个数字定义了响应的类别</p>
<ul>
<li>1XX Information 信息性（接收的请求正在处理）</li>
<li>2XX Success 成功（请求处理完毕）</li>
<li>3XX Redirection 重定向（需要附加操作以完成请求）</li>
<li>4XX Client Error 客户端错误（服务器无法处理请求）</li>
<li>5XX Server Error 服务器错误（服务器处理请求出错）</li>
</ul>
<h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><ul>
<li>200 OK    客户端请求成功</li>
<li>204 No Content   无内容</li>
<li>301 Moved Permanently  资源永久移动（永久重定向）</li>
<li>302 Found  资源临时移动（临时重定向）</li>
<li>303 See Other   303功能与302一样，区别只是303明确客户端应该使用GET访问</li>
<li>304 Not Modified 这个码虽然是3XX，但是和重定向没关系（资源已找到，但是没有符合条件）</li>
<li>307 Temporary Redirect   </li>
<li>400 Bad Request 请求报文语法错误</li>
<li>401 Unauthorized 第一次返回求认证，第二次返回认证失败</li>
<li>403 Forbidden 服务器不允许访问那个资源</li>
<li>404 Not Found 找不到请求的资源</li>
<li>500 服务器出错了</li>
<li>503 服务器停止工作或者在忙</li>
</ul>
<h1 id="HTTP1-0-HTTP1-1区别"><a href="#HTTP1-0-HTTP1-1区别" class="headerlink" title="HTTP1.0 HTTP1.1区别"></a>HTTP1.0 HTTP1.1区别</h1><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用<strong>keep-alive参数</strong>来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数</p>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>HTTP2.0的主要优点有采用二进制帧封装，传输变成多路复用，流量控制算法优化，服务器端推送，首部压缩，优先级等特点</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p>
<p>端口是443</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>SSL建立连接过程</p>
<h1 id="现代网络应用的两种主流体系结构："><a href="#现代网络应用的两种主流体系结构：" class="headerlink" title="现代网络应用的两种主流体系结构："></a>现代网络应用的两种主流体系结构：</h1><ul>
<li>C/S 客户端/服务器   例子有WEB应用程序</li>
<li>P2P 对等</li>
</ul>
<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>套接字是一台主机的应用层和传输层之间的<strong>接口</strong><br>进程（应用层）通过套接字接口访问TCP（传输层）</p>
<h1 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h1><p>URL地址=主机名+对象的路径名</p>
<p>cookie详解</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>1.HTTP端口<br>默认使用80端口，客户端向服务器的80端口建立一个TCP连接<br>2.浏览器点开网页的过程<br>(1)浏览器分析URL<br>(2)浏览器向dns服务器请求解析IP地址<br>(3)DNS解析出IP地址<br>(4)浏览器与服务器建立TCP连接<br>(5)请求文件-响应<br>(6)关闭TCP连接<br>(7)浏览器显示</p>
<p>3.请求一个HTML的时间<br>客户端前两次握手，是一个RTT<br>客户端将第三次握手的ACK报文与一个HTTP请求报文结合发送，然后返回HTML文件，这是一个RTT<br>所以一共花费 2个RTT</p>
]]></content>
  </entry>
  <entry>
    <title>tcp面试题</title>
    <url>/tantian123.github.io/2020/05/20/tcp%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="tcp总结"><a href="#tcp总结" class="headerlink" title="tcp总结"></a>tcp总结</h1><ul>
<li><p>tcp/udp首部报文</p>
</li>
<li><p>三次握手 四次挥手 状态变换</p>
</li>
<li><p>tcp的流量控制</p>
</li>
<li><p>tcp的拥塞控制</p>
</li>
<li><p>常见的面试题</p>
</li>
</ul>
<p>tcp连接的每一端口，都由一个接收缓存、一个发送缓存和几个变量（lastByteRead RcvWindow Conwin）</p>
<p>RTT 往返时延<br>分组从客户端到服务器再回到客户端的时间<br>=分组传播时延+路由器/交换机上的排队时延+分组处理时延</p>
<h2 id="1-tcp-udp报文"><a href="#1-tcp-udp报文" class="headerlink" title="1.tcp/udp报文"></a>1.tcp/udp报文</h2><p>tcp报文=tcp首部字段+数据字段<br>源端口，目的端口，序号seq，确认号ack，控制位（ACK SYN FIN）,窗口</p>
<p><img src="/images/1.jpg" alt="tcp"></p>
<p>控制位 是6bit</p>
<p>udp报文=源端口号+目的端口号+长度（总长度）+校验和+数据字段</p>
<h3 id="tcp-udp的区别"><a href="#tcp-udp的区别" class="headerlink" title="tcp/udp的区别"></a>tcp/udp的区别</h3><ul>
<li>tcp 面向连接 可靠 面向字节流<br>udp 无连接 不可靠 面向报文</li>
<li>TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。TCP通过慢开始、拥塞避免、快重传、快恢复等算法进行拥塞控制。</li>
<li>UDP首开销小，只有8个字节。TCP首部是20个字节</li>
</ul>
<h2 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2.三次握手 四次挥手"></a>2.三次握手 四次挥手</h2><p><strong>主要关注控制位，序号，确认号，状态</strong><br><img src="/images/2.jpg" alt="tcp"></p>
<p>序列号/确认号的作用<br>序列号：<br>每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号<br>确认号：<br>告诉对方我已经收到xx，下次期望收到对方下个报文段的第一个数据字节的序号（下次的第一个字节）</p>
<p>序列号保证了传输的数据包的顺序</p>
<p>用tcp发送了一个数据包后，会把它放到重发队列里，同时计时，<br>如果收到了这个包的确认信息，就会将这个包从重发队列中删除，<br>如果在计时器超时内，没收到确认信息，就会进行重发</p>
<p>初始序列号(ISN) 是随机值  有client_isn和server_isn</p>
<h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1.三次握手"></a>2.1.三次握手</h3><ol>
<li><p>SYN=1 seq=x （也就是client_isn）<br>客户端发送SYN包到服务器<br>此后，客户端状态SYN_SENT</p>
</li>
<li><p>ACK=1 SYN=1 seq=y（也就是server_isn） ack=x+1<br>服务器收到SYN包，服务器返回SYNACK包，<br>此后，服务器状态SYN_RECV</p>
</li>
<li><p>ACK=1 seq=x+1  ack=y+1  SYN=0<br>客户端收到SYNACK包，发送ACK包给服务器<br>服务器收到<br>此后，客户端/服务器状态 ESTABLISHED（TCP连接成功）</p>
</li>
</ol>
<p>通过三次握手，通信双方了解了如下信息<br>1、对方报文发送的开始序号。<br>2、对方发送数据的缓冲区大小。<br>3、能被接收的最大报文段长度MSS。<br>4、被支持的TCP选项。</p>
<p>另一种理解，通过三次握手，通信双方都明确自己和对方的收、发能力是正常的<br>第一次握手（服务器端知道自己的收能力，和客户端的发能力）<br>第二次握手（客户端知道自己的收发能力和服务器端的收发能力）<br>第三次握手（服务器知道自己的发能力和客户端的收能力）</p>
<h3 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2.四次挥手"></a>2.2.四次挥手</h3><ol>
<li><p>FIN=1 ACK=1 seq=x ack=z<br>客户端发出连接释放报文<br>此后，客户端状态FIN_WAIT_1</p>
</li>
<li><p>ACK=1 seq=z ack=x+1<br>服务器收到后，发出确认报文（此时服务器还没发完，不能关闭）<br>此后，客户端状态  FIN_WAIT_1<br>服务器端状态  CLOSE_WAIT</p>
</li>
<li><p>FIN=1 ACK=1 seq=y ack=x+1<br>服务器传完后，就发送连接释放报文<br>此后，服务器状态LAST_ACK </p>
</li>
<li><p>ACK=1 seq=x+1 ack=y+1<br>客户端收到连接释放报文，发出确认报文<br>此后，客户端进入TIME_WAIT状态</p>
</li>
</ol>
<p>此时还要等待2MSL（最长报文段寿命）客户端才撤销TCB 进入CLOSED状态<br>服务器端收到客户端的确认报文，立刻进入CLOSED状态，所以服务器结束得早一点</p>
<h2 id="3-tcp流量控制"><a href="#3-tcp流量控制" class="headerlink" title="3.tcp流量控制"></a>3.tcp流量控制</h2><p>tcp让发送方维护一个接收窗口的变量来实现流量控制   RcvWindow<br>接收窗口用于告诉发送方，你的接收方还有多少缓存可用<br>两边都各自维护一个接收窗口，同时TCP不允许缓存溢出<br>主机B把当前的接收窗口值放入它发给主机A的TCP报文段里的接收窗口字段，通过控制未确认的数据量在接收窗口以内</p>
<p>当然，这个方案存在一个技术问题，<br>考虑一种特殊情况，当接收方B缓存满了，那么发送方A的接收窗口设为0，而之后如果接收方B缓存清空，发送方A就一直阻塞，不发。<br>解决方案：TCP规约中要求，接收窗口为0时，发送方A会继续发送只有一个字节的报文段，一旦缓存清空了，接收方B就会返回一个非0的窗口值。</p>
<h2 id="4-tcp拥塞控制"><a href="#4-tcp拥塞控制" class="headerlink" title="4.tcp拥塞控制"></a>4.tcp拥塞控制</h2><p>每一端都记录一个变量——拥塞窗口，CongWin。<br>它对一个TCP发送方，发送的速率进行了限制。<br>即 发送方未确认的数据量   (LastByteSend-LastByteAcked)&lt;=min(CongWin,RcvWindow)</p>
<p>TCP是如何感知阻塞的呢？</p>
<p>解决办法：<br>1.慢启动<br>2.拥塞避免<br>3.快重传<br>4.快恢复</p>
<h2 id="5-常见的面试题"><a href="#5-常见的面试题" class="headerlink" title="5.常见的面试题"></a>5.常见的面试题</h2><p>为什么需要初始序号<br>    为了避免安全攻击。初始序号是随机的<br>为什么不是二次握手<br>    主要为了防止A已失效的连接请求报文段突然又传送到了B，因而产生错误。如果没有第三次握手，B收到消息就会立马建立连接。<br>为什么要等待2MSL/为什么需要TIME_WAIT<br>    MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”<br>    为了保证A发送的最后一个ACK报文能够到达B ，如果A不等待，此时B没收到A的ACK，B就不会关闭</p>
<p>TIME_WAIT的危害<br>    在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态（大量TIME_WAIT的条件：高并发，服务器主动关闭）<br>    服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。<br>如何解决<br>    允许端口可重用<br>    服务器不主动关闭连接</p>
<p>为什么是四次挥手（关键在于挥手是需要等的，而握手是随时可以的）<br>    第一次挥手 A不主动发了，仍然可以接收<br>    第二次挥手 B告诉A 我知道你的情况了 但是我还没发完，等会<br>    第三次挥手 B告诉A 我处理完了，我不主动发了<br>    第四次挥手 A告诉B 你可以关闭接收了</p>
<p>syn洪泛攻击<br>    服务器响应SYN 会分配并初始化变量和缓存，消耗资源<br>    攻击者发送大量的TCP SYN报文段，而不进行第三次握手。导致服务器资源消耗殆尽。<br>    现在的防御手段，SYN cookies<br>三次握手过程中可以携带数据吗<br>    第三次握手允许携带数据<br>linux系统的nmap工具 （端口扫描工具）<br>    没用过</p>
]]></content>
      <tags>
        <tag>面向面试编程</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 136. Single Number</title>
    <url>/tantian123.github.io/2020/04/02/leetcode-136-Single-Number/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>这是一道Bit Operation位操作的题目<br>异或XOR操作：相同为0，不同为1<br>相同元素出现两次即出现两次变号  0-&gt;1-&gt;0(或1-&gt;0-&gt;1)<br>只出现一次的元素只变号一次     0-&gt;1(或1-&gt;0)</p>
<p>文字描述不够直观<br><strong>接下来直接举例，[1,2,3,4,1,2,3]  输出4</strong><br>res=1 ^ 2 ^ 3 ^ 4 ^ 1^ 2 ^ 3=(1 ^ 1) ^ (2 ^ 2)^(3 ^ 3)^ 4=0^ 0^ 0^4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] -&gt; 0-0-0-1   //与下面的进行异或操作</span><br><span class="line">[2] -&gt; 0-0-1-0   //(0-0-0-1)+(0-0-1-0)=(0-0-1-1) </span><br><span class="line">[3] -&gt; 0-0-1-1   //(0-0-1-1)+(0-0-1-1)=(0-0-0-0)</span><br><span class="line">[4] -&gt; 0-1-0-0   //(0-0-0-0)+(0-1-0-0)=(0-1-0-0)</span><br><span class="line">[1] -&gt; 0-0-0-1   //(0-1-0-0)+(0-0-0-1)=(0-1-0-1)</span><br><span class="line">[2] -&gt; 0-0-1-0   //(0-1-0-1)+(0-0-1-0)=(0-1-1-1)</span><br><span class="line">[3] -&gt; 0-0-1-1   //(0-1-1-1)+(0-0-1-1)=(0-1-0-0)</span><br><span class="line">//最后输出结果为0-1-0-0，即为十进制数4.</span><br></pre></td></tr></table></figure>

<h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>java进行按位异或操作  c = a ^ b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">            nums[i]=nums[i-1]^nums[i];</span><br><span class="line">        return nums[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令</title>
    <url>/tantian123.github.io/2020/04/02/hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line">简写为</span><br><span class="line">hexo n &quot;我的博客&quot;</span><br></pre></td></tr></table></figure>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate </span><br><span class="line">简写为</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">简写为</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h3 id="预览博文效果"><a href="#预览博文效果" class="headerlink" title="预览博文效果"></a>预览博文效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debug 在本地浏览器的localhost:4000</span><br></pre></td></tr></table></figure>
<h3 id="三连"><a href="#三连" class="headerlink" title="三连"></a>三连</h3><p>在blog根目录下的source文件夹中的_post文件夹中打开命令行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="导入图片"><a href="#导入图片" class="headerlink" title="导入图片"></a>导入图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![简介](/images/xx.jpg)</span><br></pre></td></tr></table></figure>

<h3 id="新增分类选项"><a href="#新增分类选项" class="headerlink" title="新增分类选项"></a>新增分类选项</h3><p>一篇文章只会添加到一个分类中</p>
<p>1.创建分类页面（第一次才要）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>2.找到source/categories/index.md<br>加入一个键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: categories</span><br></pre></td></tr></table></figure>
<p>3.给每篇文章加属性<br>给文章添加“categories”属性<br>表示添加到到“Hexo”这个分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>




<h3 id="新增标签选项"><a href="#新增标签选项" class="headerlink" title="新增标签选项"></a>新增标签选项</h3><p>一篇文章有多个标签</p>
<p>1.生成“标签”页并添加tpye属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>2.在tags文件夹下，找到index.md这个文件<br>加入一个键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: tags</span><br></pre></td></tr></table></figure>

<p>3.为其添加tags属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- 日记</span><br><span class="line">- 2020</span><br><span class="line">- 私密</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
