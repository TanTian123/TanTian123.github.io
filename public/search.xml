<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java深拷贝和浅拷贝</title>
    <url>/tantian123.github.io/2020/07/09/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>复制变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=a;</span><br></pre></td></tr></table></figure>
<p>复制对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1=<span class="keyword">new</span> Student(<span class="string">"s1"</span>);</span><br><span class="line">Student s2=s1;</span><br><span class="line">s2.name=<span class="string">"s2"</span>;</span><br><span class="line">System.out.println(s1.name);</span><br></pre></td></tr></table></figure>
<p>它们指向同一个对象</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>拷贝出一个全新的对象，与之前无关</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>复制了之前对象的引用，并没有开辟新的空间</p>
<p>使用clone方法和直接赋值 都是浅拷贝<br>Object中本地clone()方法，默认是浅拷贝<br>如果要深拷贝，要重写clone方法</p>
]]></content>
  </entry>
  <entry>
    <title>详解布隆过滤器</title>
    <url>/tantian123.github.io/2020/07/09/%E8%AF%A6%E8%A7%A3%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><h2 id="1-构成"><a href="#1-构成" class="headerlink" title="1.构成"></a>1.构成</h2><p>一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）</p>
<h3 id="bitarray-bitmap"><a href="#bitarray-bitmap" class="headerlink" title="bitarray/bitmap"></a>bitarray/bitmap</h3><p>一个数组，数组每一位存储一个bit，每个bit只能是0或者1</p>
<h3 id="多个哈希函数"><a href="#多个哈希函数" class="headerlink" title="多个哈希函数"></a>多个哈希函数</h3><p>有k个hash函数，<br>将得到的值，对应在bitarray上，标记为1</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><h3 id="可能在集合中-绝对不在集合中"><a href="#可能在集合中-绝对不在集合中" class="headerlink" title="可能在集合中 绝对不在集合中"></a>可能在集合中 绝对不在集合中</h3><p>我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中。</p>
<h2 id="3-作用"><a href="#3-作用" class="headerlink" title="3.作用"></a>3.作用</h2><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>存放01 所以占用内存少，查询快</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>数据增加，误判率会增加，且无法撤回已加入的值,无法确定数据一定存在</p>
<h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h2><p>两个方面：缓存穿透和 大量数据，判断给定值的是否在其中</p>
<p>布隆过滤器广泛应用于网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统等</p>
<h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5.实现"></a>5.实现</h2><p>guava实现<br>redis实现布隆过滤器</p>
]]></content>
  </entry>
  <entry>
    <title>redis快速入门</title>
    <url>/tantian123.github.io/2020/07/08/redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Nosql 数据库<br>基本数据类型<br>只存KV形式<br>K是字符串<br>V有5种形式：<br>String 字符串<br>HashMap 哈希表<br>List 列表<br>Set 集合<br>ZSet 有序集合</p>
<p>查询速度快，完全在内存中，没有磁盘的IO</p>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>略</p>
<h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>图形化界面 redis Desktop Manager</p>
<h1 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h1><p>运行redis-server.exe 监听6379端口<br>运行redis_cli,exe 会去连接6379</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>set k1 v1<br>get k1<br>del k1</p>
<p>mset k1 v1 k2 v2<br>mget k1 k2</p>
<hr>
<p>hset h1 name tt<br>hget h1 name<br>hset h1 name tt2<br>hmset h1 name tt age 20 (多个值要用mset)</p>
<p>hgetall h1</p>
<p>del h1<br>hdel h1 age</p>
<hr>
<p>list只有push和pop的方法</p>
<p>lpush L1 v1  加在左边<br>lpush L1 v1 v2 v3 v4 v5<br>lrange L1 0 2 查询0 1 2三个元素（-1代表无穷）<br>没有rrange<br>rpush L1 r1 r2 r3 加在右边</p>
<p>lpop L1<br>rpop L1</p>
<hr>
<p>Set<br>sadd S1 v1<br>smembers S1 获取所有元素</p>
<hr>
<p>shutdown 关闭</p>
<h1 id="订阅和发布"><a href="#订阅和发布" class="headerlink" title="订阅和发布"></a>订阅和发布</h1><p>类似消息队列</p>
<p>打开两个客户端AB<br>A输入<br>subscribe foo<br>进入订阅模式<br>B输入<br>publish foo hellooooo<br>进行发布<br>A收到hellooooo</p>
<p>此外，订阅还支持通配符 a?b a*b</p>
<h1 id="redis优缺点"><a href="#redis优缺点" class="headerlink" title="redis优缺点"></a>redis优缺点</h1><p>性能高<br>原子性<br>高速读写</p>
<p>持久化代价高<br>占用内存过多</p>
<h1 id="redis的内存维护策略"><a href="#redis的内存维护策略" class="headerlink" title="redis的内存维护策略"></a>redis的内存维护策略</h1><p>1.为数据设置超时时间<br>expire key time 单位是秒<br>作用：手机验证码/限制访问频率/限时活动/微博热搜</p>
<p>ttl key 查看过期时间<br>2.采用LRU<br>volatile-lru<br>allkeys-lru</p>
<h1 id="redis面试题"><a href="#redis面试题" class="headerlink" title="redis面试题"></a>redis面试题</h1>]]></content>
  </entry>
  <entry>
    <title>java线程池总结</title>
    <url>/tantian123.github.io/2020/07/06/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Executor<br>ThreadPoolExecutor</p>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>JUC</p>
<h2 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h2><p>一项任务的时间=线程创建时间+任务执行过程时间+线程销毁时间<br>线程池通过复用线程，减少创建时间和销毁时间</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>一共三次判断，<br>使用者提交任务<br>1.如果线程池中的线程小于corePoolSize时（即核心线程未满）<br>就会创建新线程直接执行任务。</p>
<p>2.如果线程池中的线程大于corePoolSize时（核心线程满了）<br>就会暂时把任务存储到工作队列workQueue中等待执行。</p>
<p>3、如果工作队列workQueue也满时：<br>当线程数小于最大线程池数maximumPoolSize时，就会创建新线程（救急线程）来处理，<br>而线程数大于等于最大线程池数maximumPoolSize时，就会执行拒绝策略。</p>
<h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><p>高三位线程状态  低29位线程数量</p>
<p>7个参数，注意参数类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,  </span><br><span class="line">                              int maximumPoolSize,  </span><br><span class="line">                              long keepAliveTime,  </span><br><span class="line">                              TimeUnit unit,  </span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,  </span><br><span class="line">                              ThreadFactory threadFactory,  </span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>其中的线程包括：核心线程和救急线程<br>核心线程不会销毁 救急线程有最大生存时间</p>
<p>corePoolSize线程池的核心线程数目<br>maximumPoolSize最大线程数目<br>keepAliveTime空余线程存活时间，指的是超过corePoolSize的空余线程达到多长时间才进行销毁。<br>unit销毁的时间单位。<br>workQueue存储等待执行线程的工作队列。<br>threadFactory创建线程的工厂，一般用默认即可。<br>handler拒绝策略，当工作队列、线程池全已满时如何拒绝新任务，默认抛出异常。</p>
<h2 id="jdk提供的四种拒绝策略"><a href="#jdk提供的四种拒绝策略" class="headerlink" title="jdk提供的四种拒绝策略"></a>jdk提供的四种拒绝策略</h2><p>DiscardPolicy 放弃这个任务<br>OldestDiscardPolicy 放弃队列中最早的任务，取而代之<br>CallerRunsPolicy  运行任务<br>AbortPolicy 默认的策略，抛出RejectedExecutionException异常</p>
<p>其它第三方框架并没有使用jdk提供的，<br>dubbo  抛出RejectedExecutionException异常，并进行日志记录<br>netty 创建一个新线程<br>ActiveMQ 超市等待60s后尝试放入</p>
<h2 id="常用的几个"><a href="#常用的几个" class="headerlink" title="常用的几个"></a>常用的几个</h2><h3 id="newFixedThreadPool固定大小的线程池"><a href="#newFixedThreadPool固定大小的线程池" class="headerlink" title="newFixedThreadPool固定大小的线程池"></a>newFixedThreadPool固定大小的线程池</h3><h3 id="newCachedThreadPool带缓冲的线程池"><a href="#newCachedThreadPool带缓冲的线程池" class="headerlink" title="newCachedThreadPool带缓冲的线程池"></a>newCachedThreadPool带缓冲的线程池</h3><h3 id="newSingleThreadExecutor单线程线程池"><a href="#newSingleThreadExecutor单线程线程池" class="headerlink" title="newSingleThreadExecutor单线程线程池"></a>newSingleThreadExecutor单线程线程池</h3><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3>]]></content>
  </entry>
  <entry>
    <title>java继承和实现</title>
    <url>/tantian123.github.io/2020/07/02/java%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在看runnablefuture 的源码时<br>看到接口继承了接口，使用的是extends</p>
]]></content>
  </entry>
  <entry>
    <title>springboot学习</title>
    <url>/tantian123.github.io/2020/06/29/springboot%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>开启了各种自动装配，简化了代码开发，不需要各种配置文件，只需要引入相关的依赖。<br>不需要 web.xml springmvc.xml 且tomcat内嵌在框架中<br>不需要配置JSON解析，支持REST<br>能个性化配置</p>
<p>所以我们直接写注解就行，不用扫描的配置</p>
<hr>
<p>使用：<br>创建maven工程，导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--先引父包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>写以下文件</p>
<p>启动内置的tomcat，创建一个启动类<br>类的注解是@SpringBootApplication，是启动的入口</p>
<p>static文件夹是spring默认的一个扫描路径，可以在地址栏直接访问</p>
<h2 id="整合html-使用thymeleaf模板"><a href="#整合html-使用thymeleaf模板" class="headerlink" title="整合html 使用thymeleaf模板"></a>整合html 使用thymeleaf模板</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;message&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如何放,还是用model传<br>如何取,</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xml:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"student:$&#123;list&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;student.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;student.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;student.age&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时配置映射</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.thymeleaf.prefix</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="meta">spring.thymeleaf.suffix</span>=<span class="string">.html</span></span><br><span class="line"><span class="meta">spring.thymeleaf.encoding</span>=<span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>

<h4 id="thymeleaf常用语法"><a href="#thymeleaf常用语法" class="headerlink" title="thymeleaf常用语法"></a>thymeleaf常用语法</h4><p>1.赋值<br>2.拼接<br>3.条件判断 if/unless 成立时/不成立时，显示内容<br>4.循环<br>5.stat中可以取出信息 stat是一个状态变量，可以取index/count/size/current/even/odd/first/last等信息<br>6.th:style添加样式<br>7.url 添加链接 使用@{…} a标签结合th:href th:src </p>
<h1 id="springboot数据校验"><a href="#springboot数据校验" class="headerlink" title="springboot数据校验"></a>springboot数据校验</h1><p>数据格式的校验还是放在前端好些，</p>
<p><a href="https://www.cnblogs.com/love-wzy/p/10348519.html" target="_blank" rel="noopener">https://www.cnblogs.com/love-wzy/p/10348519.html</a></p>
<p>@NotNull注解<br>@NotNull(message=”id不能是空的”)</p>
<p>@NotEmpty注解<br>notnull是没传，notempty是为空</p>
<p>@Length<br>@Future<br>@Min</p>
<h1 id="springboot整合jdbc"><a href="#springboot整合jdbc" class="headerlink" title="springboot整合jdbc"></a>springboot整合jdbc</h1><p>相关依赖<br>数据源</p>
<p>spring-boot-starter-jdbc<br>mysql-connector-java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java枚举使用详解</title>
    <url>/tantian123.github.io/2020/06/29/java%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>应用场景：有些类的实例对象是固定的，比如 一星期只有七天<br>枚举就是针对这些场景设计的。<br>结合switch case使用，减少了大量的ifelse语句</p>
<p>定义常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里命名的后缀建议是Enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ThreadStateEnum&#123;</span><br><span class="line">    NEW,RUNNABLE,BLOCKED,WAITTING,TIME_WAITTING,TERMINATED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadStateEnum <span class="keyword">enum</span>=ThreadStateEnum.NEW;</span><br></pre></td></tr></table></figure>

<p>结合switch使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadStateEnum state=ThreadStateEnum.NEW;</span><br><span class="line">    <span class="keyword">switch</span>(state)&#123;</span><br><span class="line">        <span class="keyword">case</span> NEW: </span><br><span class="line">            System.out.println(<span class="string">"new"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对枚举类添加方法</p>
<p>``` java<br>public enum ThreadStateEnum{<br>    NEW(“new”,1),RUNNABLE,BLOCKED,WAITTING,TIME_WAITTING,TERMINATED;<br>    private String name;<br>    private int index;</p>
<pre><code>// 构造方法  
private ThreadStateEnum(String name, int index) {  
    this.name = name;  
    this.index = index;  
}

public String getName(){
    return name;
}</code></pre><p>}</p>
]]></content>
  </entry>
  <entry>
    <title>类加载和双亲委派机制</title>
    <url>/tantian123.github.io/2020/06/29/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h1><p>了解类的加载</p>
<p>五个过程，载入、链接（验证、准备、解析）和初始化<br>载入，将类的class文件读入内存，并为它创建一个java.lang.class对象<br>验证，对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行<br>准备，对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化<br>解析，将常量池中的符号引用转化为直接引用<br>初始化，</p>
<p>了解类加载器<br>类的加载由类加载器完成，类加载器是JVM提供的<br>了解类加载器的分类<br>bootstrap class loader 启动类加载器<br>加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar。<br>extensions class loader 扩展类加载器<br>加载 jre/lib/ext 包下面的 jar 文件<br>system class loader 应用类加载器<br>根据程序的类路径（classpath）来加载 Java 类<br>了解类加载机制<br>三种，全盘负责，双亲委派，缓存机制</p>
<p><strong>类加载器的层次关系，就是类加载器的双亲委派模型。</strong></p>
<h1 id="如何运行的"><a href="#如何运行的" class="headerlink" title="如何运行的"></a>如何运行的</h1><p>如果一个类加载器收到类加载的请求，首先不会自己去加载这个类，而是将请求委派给父类加载器，直到顶层。<br>如果父类无法完成即搜索范围内没有这个类，就会让子加载器自己完成。</p>
<h1 id="为什么需要，好处"><a href="#为什么需要，好处" class="headerlink" title="为什么需要，好处"></a>为什么需要，好处</h1><p>避免了多个同样的字节码的重复加载，比如说类A和类B都需要加载System类，那么不使用委托机制，两个类都会加载一份System的字节码；如果使用委托机制，就会递归地向父类查找，此时，如果类A加载了，类B再去请求，就会直接返回那份字节码文件，而不是重新加载。<br>防止核心API库被修改</p>
<h1 id="如何实现自定义类加载器"><a href="#如何实现自定义类加载器" class="headerlink" title="如何实现自定义类加载器"></a>如何实现自定义类加载器</h1><p>继承ClassLoader，重载findClass方法</p>
]]></content>
  </entry>
  <entry>
    <title>java网络编程1</title>
    <url>/tantian123.github.io/2020/06/28/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
    <content><![CDATA[<p>本书结构<br>I/O和线程<br>流<br>线程<br>Internet地址<br>URL URI<br>HTTP<br>Socket类<br>非阻塞I/O<br>UDP</p>
<p>第一章</p>
<p>TCP/IP参考模型<br>数据链路层  ARP和RARP<br>网络层  IP ICMP<br>传输层  TCP UDP<br>应用层 HTTP DNS POP FTP</p>
<p>java不支持ICMP 所以java唯一的网络层协议是IP<br>也不支持发送原始IP数据报，只允许TCP UDP</p>
<p>IP地址</p>
<p>端口1-65535<br>HTTP是80</p>
<p>代理服务器：防火墙 本地缓存<br>代理服务器可以理解HTTP FTP SMTP ，但是不能理解自定义的协议</p>
<p>第二章</p>
<p>java独特的I/O流<br>建立在stream之上，输入流读取数据，输出流写入数据<br>filter过滤器可以串到输入/输出流上，过滤器可以修改数据或者是提供额外的方法<br>reader和writer同样，允许程序读写文本（即字符）而不是字节。</p>
<p>流是同步的，</p>
<p>输出流<br>OutputStream<br>方法 write<br>flush 缓冲区未满，强迫发送<br>close 释放文件句柄或者端口</p>
<p>子类使用这些方法，向特定的介质中写入数据。例如Bytexxx</p>
<p>输入流<br>InputStream<br>Filexxx从文件<br>Telnetxxx从网络连接中</p>
<p>read 流的结束是返回-1，输入输出很慢，所以通常放在线程里<br>close</p>
<p>过滤器输出流<br>PrintStream<br>例如System.out</p>
<p>InetAddress类<br>包括一个主机名和一个IP地址<br>Socket ServerSocket URL DatagramSocket DatagramPacket等类都使用到了这个</p>
<p>该类没有公共构造函数（非公开），通过静态工厂来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> InetAddress[] getAllByName(String host)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getByAddress</span><span class="params">(<span class="keyword">byte</span>[] addr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getByAddress</span><span class="params">(String host,<span class="keyword">byte</span>[] addr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getByName</span><span class="params">(String host)</span> <span class="comment">//可以通过域名或者IO创建</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getLocalHost</span><span class="params">()</span> <span class="comment">//获得本机地址对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">getHostName</span><span class="params">()</span></span>;<span class="comment">//获得对象中存储的域名</span></span><br><span class="line">getHostAddress();<span class="comment">//获得对象中存储的IP</span></span><br></pre></td></tr></table></figure>






<p>java.net.URL<br>是一个final类，不可再变，保证了线程安全<br>使用了策略设计模式<br>这个对象的自动包括，协议 主机名 端口号 路径 ref 查询字符串等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL(String url)</span><br><span class="line">URL(String protocol,String hostname,String file)</span><br></pre></td></tr></table></figure>


<p>URLEncoder<br>URLEncoder.encode(“”,”UTF-8”);<br>URLDecoder<br>URLDecoder.decode(“”,”UTF-8”);</p>
<p>TCP编程<br>利用socket建立连接，然后从连接中获取它的输入输出流即可<br>利用serversocket接收</p>
<p>如何复用socket连接<br>循环<br>如何使服务端支持多个客户端连接<br>线程</p>
<p>UDP编程<br>DatagramSocket类<br>DatagramPacket类 数据封装</p>
<p>BIO NIO AIO</p>
<p>服务器端启动一个 ServerSocket<br>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯<br>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝<br>如果有响应，客户端线程会等待请求结束后，在继续执行</p>
]]></content>
  </entry>
  <entry>
    <title>spring入门</title>
    <url>/tantian123.github.io/2020/06/26/spring%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>spring实现依赖注入<br>spring实现面向切面编程</p>
<p>spring框架的两大核心机制<br>IoC/DI  控制反转/依赖注入<br>AOP   面向切面编程</p>
<h1 id="spring的概念"><a href="#spring的概念" class="headerlink" title="spring的概念"></a>spring的概念</h1><p>企业级的开发框架，将应用程序进行分层，自主选择组件</p>
<p>MVC Struts2 SpringMVC<br>ORM层 Hibernate MyBatis Spring Data</p>
<h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>在传统的开发中，调用对象时，通常是调用者new一个对象</p>
<p>而在spring框架中，创建对象不再由调用者负责，而是交给Ioc容器创建，<br>再推送给调用者。</p>
<p>目的：解耦合</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><bean>标签就是一个对象<br>id  相当于对象名<br>class属性  对应的是对象的模板类（所有交给Ioc容器的类 必须有无参构造）<br>它的子标签<property> 就是其成员变量<br>子标签的name 是属性名 value是值（基本数据类型和String才能赋值，如果是其它，不能通过value赋值 ）<br>ref 将Ioc中的另外一个bean赋给当前成员变量，这就是DI</p>
<p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--bean命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.tt.entity.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"谭天"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line">ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">Student student1= (Student) applicationContext.getBean(<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="如果是嵌套的类"><a href="#如果是嵌套的类" class="headerlink" title="如果是嵌套的类"></a>如果是嵌套的类</h3><p>student里面有address类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.tt.entity.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"谭天"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.tt.entity.Address"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myaddress"</span> <span class="attr">value</span>=<span class="string">"fengc"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="IoC的底层原理"><a href="#IoC的底层原理" class="headerlink" title="IoC的底层原理"></a>IoC的底层原理</h2><p>1.加载这个配置文件，解析xml<br>2.通过反射机制实例化配置文件中配置的所有bean</p>
<h3 id="dom4j实现ioc的底层"><a href="#dom4j实现ioc的底层" class="headerlink" title="dom4j实现ioc的底层"></a>dom4j实现ioc的底层</h3><p>用到了xml解析和反射的原理</p>
<ul>
<li>导入依赖</li>
<li>写ApplicationContext接口</li>
<li>写ApplicationContext的实现类ClassPathXmlApplicationContext</li>
<li>实现getBean方法，这个方法返回一个对象</li>
</ul>
<h2 id="问题：一个类同时只能存在一个实例-（运行时类获取bean）"><a href="#问题：一个类同时只能存在一个实例-（运行时类获取bean）" class="headerlink" title="问题：一个类同时只能存在一个实例 （运行时类获取bean）"></a>问题：一个类同时只能存在一个实例 （运行时类获取bean）</h2><p>如何解决：通过有参构造创建bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--name属性可省略  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student2"</span> <span class="attr">class</span>=<span class="string">"com.tt.entity.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小天"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>什么是AOP<br>面向切面编程，我们开发是纵向开发，横向扩展的。</p>
<p>如何实现AOP<br>通过动态代理的方法，来实现AOP的思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add方法的参数是"</span>+num1 + <span class="string">","</span> + num2);</span><br><span class="line">        <span class="keyword">int</span> result=num1+num2;</span><br><span class="line">        System.out.println(<span class="string">"add方法的结果是"</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cal cal=<span class="keyword">new</span> CalImpl();</span><br><span class="line">cal.add(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码，日志信息和业务逻辑的耦合高，不利于维护，故使用AOP优化<br>给业务代码找一个代理，打印日志信息的工作由代理来做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样的业务代码非常纯粹</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=num1+num2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cal cal=<span class="keyword">new</span> CalImpl();<span class="comment">//创建委托对象</span></span><br><span class="line">MyInvocationHandler myInvocationHandler=<span class="keyword">new</span> MyInvocationHandler();<span class="comment">//实例化MyInvocationHandler帮助我创建代理对象</span></span><br><span class="line">Cal cal1= (Cal) myInvocationHandler.bind(cal);<span class="comment">//返回代理对象</span></span><br><span class="line">cal1.add(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//这个是代理对象调用方法</span></span><br></pre></td></tr></table></figure>
<p>MyInvocationHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//委托对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//返回代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">"方法参数是"</span>+ Arrays.toString(args));</span><br><span class="line">        Object result=method.invoke(<span class="keyword">this</span>.object,args);</span><br><span class="line">        System.out.println(method.getName()+<span class="string">"的结果是"</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是原生的动态代理，spring框架对其进行了封装<br>用面向对象的思想实现AOP，创建一个切面对象，所有非业务代码在切面对象中完成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h3 id="1-具体方法处的注解"><a href="#1-具体方法处的注解" class="headerlink" title="1.具体方法处的注解"></a>1.具体方法处的注解</h3><p>注解@Before(“execution(public int 包名.方法名())”)或者用通配符*替代方法名</p>
<h3 id="2-在aspect类定义处的注解，面向对象"><a href="#2-在aspect类定义处的注解，面向对象" class="headerlink" title="2.在aspect类定义处的注解，面向对象"></a>2.在aspect类定义处的注解，面向对象</h3><ul>
<li>Aspect注解让它成为了切面对象</li>
<li>Component注解是让IOC来管理它</li>
</ul>
<p>并且在被代理类处也要加上Component注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public int com.tt.utils.impl.CalImpl.*())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取方法名</span></span><br><span class="line">        String name= joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        String args= Arrays.toString(joinPoint.getArgs());</span><br><span class="line">        System.out.println(name + <span class="string">"方法的参数是"</span> + args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalImpl</span> <span class="keyword">implements</span> <span class="title">Cal</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>


<p>最后在spring.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自动扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tt"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使得aspect注解生效,为切面自动生成代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>springMVC学习</title>
    <url>/tantian123.github.io/2020/06/23/springMVC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="javaweb项目的结构"><a href="#javaweb项目的结构" class="headerlink" title="javaweb项目的结构"></a>javaweb项目的结构</h1><p>项目名是 mvcdemo<br>即文件夹的名字是mvcdemo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">    -main</span><br><span class="line">        -java</span><br><span class="line">        -resources</span><br><span class="line">        -webapp</span><br><span class="line">            -WEB-INF</span><br><span class="line">                -web.xml</span><br><span class="line">            -index.jsp</span><br></pre></td></tr></table></figure>

<p>各个文件的作用：<br>web.xml<br>WEB-INF是收到保护的，外界不能直接通过浏览器路径访问</p>
<h1 id="MVC-一种软件设计规范"><a href="#MVC-一种软件设计规范" class="headerlink" title="MVC 一种软件设计规范"></a>MVC 一种软件设计规范</h1><p>model-dao,service<br>view  - jsp<br>controller - servlet</p>
<p>1.早期阶段<br>jsp+model层  jsp职责不单一<br>2.目前阶段<br>mvc三层  jsp只渲染页面</p>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><ul>
<li>DispatcherServlet 前置控制器，是其它组件的总指挥。</li>
<li>Handler 处理器，完成具体的逻辑，相当于servlet </li>
<li>HandlerMapping DispatcherServlet收到请求后，通过HandlerMapping把请求映射到对应的Handler（其中的Handler是包含在HandlerExecutionChain中返回的）</li>
<li>HandlerInterceptor 处理器拦截器，是一个接口，通过实现该接口完成拦截工作</li>
<li>HandlerExecutionChain 处理器执行链 包括两部分Handler和HandlerInterceptor  ，DispatcherServlet请求HandlerMapping就会返回这个HandlerExecutionChain。</li>
<li>HandlerAdapter 处理器适配器  Handler执行业务之前，需要完成表单数据的验证、数据类型转换、将表单数据封装到JavaBean等。都是适配器来完成，Handler只需要关心具体的逻辑</li>
<li>ModelAndView 装载了模型数据和视图信息，作为Handler的处理结果，返回给DispatcherServlet。<br>（ModelAndView把MVC的model层和view层整合到一起了）</li>
<li>ViewResolver 视图解析器 DispatcherServlet通过ViewResolver将逻辑视图转化为物理视图（html,jsp）,最终将渲染的结果响应给客户端</li>
</ul>
<h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>1.客户端的请求被DispatcherServlet接收<br>2.DispatcherServlet查询HandlerMapping，HandlerMapping返回HandlerExecutionChain（包含Handler和HandlerInterceptor）<br>3.DispatcherServlet通过HandlerExecutionChain，通过HandlerAdapter调用handler完成业务逻辑<br>4.HandlerAdapter执行handler，得到ModelAndView。<br>5.最后HandlerAdapter返回一个ModelAndView给DispatcherServlet<br>6.DispatcherServlet再传给ViewResolver，ViewResolver返回一个view给DispatcherServlet<br>7.DispatcherServlet根据view进行视图渲染，将结果作为服务器的响应</p>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>解耦<br>面向接口<br>开发简单，我们只需要关注handler和view和model</p>
<h1 id="spring-MVC的第一次使用"><a href="#spring-MVC的第一次使用" class="headerlink" title="spring MVC的第一次使用"></a>spring MVC的第一次使用</h1><p>springMVC的项目结构和spring不同<br>1.使用Maven搭建<br>pom.xml下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2.在web.xml下配置DispatcherServlet<br>只需要配置这一个spring自己的servlet，不用和以前一样自定义servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且在resource下新建springmvc.xml作为配置文件，此时<init-param>执行这个文件<br>3.spring.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--bean命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tt.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h1><h2 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1.@Controller"></a>1.@Controller</h2><p>相当于@Component 并且指明这是控制器<br>该类会交给Ioc容器来管理，使其成为一个控制器</p>
<h2 id="2-RequestMapping-“-index”"><a href="#2-RequestMapping-“-index”" class="headerlink" title="2.@RequestMapping(“/index”)"></a>2.@RequestMapping(“/index”)</h2><p>访问localhost:8080/index时调用<br>public String hello(){<br>    return “index”<br>}<br>这里返回的”index”  就是上面讲的逻辑视图，它会交给DispatcherServlet解析<br>解析过程：<br>（”index” 结合配置文件（前缀/后缀等）里的路径 找到webapp下的html或者jsp文件）</p>
<p>类定义处和方法定义处都可以加@RequestMapping</p>
<p>@RequestMapping的相关参数</p>
<ul>
<li>value 默认值</li>
<li>method 指定请求的method类型 post get put delete <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="comment">//表示只能接收get请求</span></span><br></pre></td></tr></table></figure></li>
<li>params 指定请求必须包含某些参数，否则无法访问<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>,method = RequestMethod.GET,params = &#123;<span class="string">"name"</span>,<span class="string">"id"</span>&#125;)</span><br><span class="line"></span><br><span class="line">此时访问方式是localhost:<span class="number">8080</span>/index?name=tt&amp;id=<span class="number">1</span></span><br></pre></td></tr></table></figure>
如果要在方法访问name和id，把它们加入到形参列表中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>,method = RequestMethod.GET,params = &#123;<span class="string">"name"</span>,<span class="string">"id"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(String name,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello index+++"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>值得注意的是，这里的参数类型的自动转换（String name,int id）是由HandlerAdapter完成的。</p>
<h2 id="3-RequestParam-“name”"><a href="#3-RequestParam-“name”" class="headerlink" title="3.@RequestParam(“name”)"></a>3.@RequestParam(“name”)</h2><p>此时如果http请求参数名和形参列表中参数名不同，使用这个注解完成参数绑定</p>
<p>默认参数value  参数赋值给形参<br>required 设置是否必须不为空<br>defaultVaule 默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>,method = RequestMethod.GET,params = &#123;<span class="string">"name"</span>,<span class="string">"id"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String str, <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">","</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>此外，springmvc也支持restful风格的URL</p>
<ul>
<li>传统url   <a href="http://localhost:9090/index?name=tt&amp;id=999" target="_blank" rel="noopener">http://localhost:9090/index?name=tt&amp;id=999</a></li>
<li>restful风格  <a href="http://localhost:9090/rest/tt/999" target="_blank" rel="noopener">http://localhost:9090/rest/tt/999</a></li>
</ul>
<p>此时修改@RequestMapping<br>并且此时参数不会自动绑定，因为restful风格的url并没有携带参数名<br>需要使用@PathVariable()</p>
<h2 id="4-PathVariable"><a href="#4-PathVariable" class="headerlink" title="4.@PathVariable()"></a>4.@PathVariable()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rest/&#123;name&#125;/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rest</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name, @<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">","</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-CookieValue-“JSESSIONID”"><a href="#5-CookieValue-“JSESSIONID”" class="headerlink" title="5.@CookieValue(“JSESSIONID”)"></a>5.@CookieValue(“JSESSIONID”)</h2><p>springmvc通过映射，可以直接在业务方法中得到cookie的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/cookie"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">cookie</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span>String sessionID)</span>&#123;</span><br><span class="line">        System.out.println(sessionID);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用的不多</p>
<h2 id="6-使用javabean绑定参数"><a href="#6-使用javabean绑定参数" class="headerlink" title="6.使用javabean绑定参数"></a>6.使用javabean绑定参数</h2><p>自动匹配/填充对象，同时支持级联</p>
<p>不是绑定参数而是绑定对象（把name和id封装起来）</p>
<p>这里也是由HandlerAdapter完成的。<br>使用form表单模拟一个post请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hello/save"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        用户id<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/save"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>并且还可以<strong>支持级联</strong>（对象中有对象）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &lt;form action=<span class="string">"/save"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户id&lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span>&gt;&lt;br/&gt;</span><br><span class="line">        用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;&lt;br/&gt;</span><br><span class="line">        用户地址&lt;input type=<span class="string">"text"</span> name=<span class="string">"address.value"</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"注册"</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h2 id="7-ResponseBody"><a href="#7-ResponseBody" class="headerlink" title="7.@ResponseBody"></a>7.@ResponseBody</h2><p>加上@ResponseBody是表示该方法的结果作为http正文 直接返回给客户端<br>不加@ResponseBody是返回给DispatcherServlet，DispatcherServlet再去通过ViewResolver找对应的页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rest/&#123;name&#125;/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rest</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name, @<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">","</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>@RequestBody<br>将http请求正文直接插入此方法</p>
<h2 id="8-参数是数组"><a href="#8-参数是数组" class="headerlink" title="8.参数是数组"></a>8.参数是数组</h2><p>例如 <a href="http://localhost:9090/array?name=tt&amp;name=bb&amp;name=cc" target="_blank" rel="noopener">http://localhost:9090/array?name=tt&amp;name=bb&amp;name=cc</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/array"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">array</span><span class="params">(String[] name)</span></span>&#123;</span><br><span class="line">       String str= Arrays.toString(name);</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




<h2 id="9-RestController"><a href="#9-RestController" class="headerlink" title="9.@RestController"></a>9.@RestController</h2><p>重复的@ResponseBody太多了<br>@RestController替换@Controller<br>表示该控制器直接把业务方法的返回值返回给客户端，不进行视图解析（逻辑视图-&gt;物理视图）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/restCol"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">restCol</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello i am restCol"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h1><p>在web.xml中添加过滤器</p>
<h1 id="使用包装类的好处"><a href="#使用包装类的好处" class="headerlink" title="使用包装类的好处"></a>使用包装类的好处</h1><p>当参数为空时，基本数据类型会报错，但是保证类可以接收null</p>
<h1 id="jsp页面的转发和重定向"><a href="#jsp页面的转发和重定向" class="headerlink" title="jsp页面的转发和重定向"></a>jsp页面的转发和重定向</h1><p>转发和重定向的区别：<br>转发是服务器跳转 地址栏不改变但是内容是其他页面，是同一次请求<br>重定向是客户端跳转 地址栏变化，是两次请求</p>
<p>springmvc默认是以转发的形式响应jsp</p>
<p>主要差别在于 url里面的forward:/还是redirect:/<br>1.转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/forward"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">forward</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/index.jsp"</span>;</span><br><span class="line">        <span class="comment">//等于 return "index"; 地址栏不变是转发</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2.重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redirect"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="springmvc数据绑定"><a href="#springmvc数据绑定" class="headerlink" title="springmvc数据绑定"></a>springmvc数据绑定</h1><p>在后端的业务方法中直接获取客户端http请求中的参数，将请求参数映射到业务方法的形参中去<br>数据绑定是HandlerAdapter来完成的00</p>
<p>JSP四大作用域对应的内置对象<br>pageContext request session application<br>模型数据的绑定是由ViewResolver完成的，我们先添加模型数据，再由ViewResolver来绑定</p>
<p>SpringMVC添加模型数据的方式：<br>1.Map<br>2.Model<br>3.ModelAndView<br>4.@SessionAttribute<br>5.@ModelAttribute</p>
<h2 id="1-requestScope-user-中获取"><a href="#1-requestScope-user-中获取" class="headerlink" title="1.${requestScope.user}中获取"></a>1.${requestScope.user}中获取</h2><p>map和model是一个意思<br>ModelAndView是由view创建的</p>
<h3 id="1-Map"><a href="#1-Map" class="headerlink" title="1 Map"></a>1 Map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewhHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Map&lt;String, User&gt; map)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">        map.put(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;requestScope.user&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-Model"><a href="#2-Model" class="headerlink" title="2 Model"></a>2 Model</h3><p>Model是由键值组成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/model"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">model</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ModelAndView"><a href="#3-ModelAndView" class="headerlink" title="3 ModelAndView"></a>3 ModelAndView</h3><p>把视图和模型组装后再返回<br>ModelAndView的构造函数 包括view/view的名字，model/map的key值和value值<br>其实 你返回”index”,也是通过map/model 初始化ModelAndView，然后返回ModelAndView,其实是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/modelAndView"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       User user=<span class="keyword">new</span> User();</span><br><span class="line">       user.setId(<span class="number">1</span>);</span><br><span class="line">       user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">       ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">       modelAndView.addObject(<span class="string">"user"</span>,user);</span><br><span class="line">       modelAndView.setViewName(<span class="string">"view"</span>);</span><br><span class="line">       <span class="keyword">return</span> modelAndView;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view =<span class="keyword">new</span> InternalResourceView(<span class="string">"/view.jsp"</span>);</span><br><span class="line">ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView(view,<span class="string">"modelname"</span>,modelvalue);</span><br></pre></td></tr></table></figure>

<h3 id="4-HttpServletRequest"><a href="#4-HttpServletRequest" class="headerlink" title="4.HttpServletRequest"></a>4.HttpServletRequest</h3><p>其实前面的都是一个间接的过程，先加到模型/对象，再加到Request里面</p>
<p>我们也可以直接加到Request里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(HttpServletRequest httpServletRequest)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">        httpServletRequest.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-加上注解的方式-ModelAttribute"><a href="#5-加上注解的方式-ModelAttribute" class="headerlink" title="5.加上注解的方式 ModelAttribute"></a>5.加上注解的方式 ModelAttribute</h3><p><strong>@ModelAttribute修饰的方式会最先于所以的代码执行</strong></p>
<p>因为@ModelAttribute修饰的代码创建了模型<br>然后我们返回视图就可以了，无需处理模型数据</p>
<p>这样二者分离了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;<span class="comment">//这里必须返回user 否则模型没有创建 </span></span><br><span class="line">    <span class="comment">//或者无需返回值， 在形参中加入Map/model 然后在方法内 map.put("user",user);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/ModelAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ModelAttribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-sessionScope-user-中获取"><a href="#2-sessionScope-user-中获取" class="headerlink" title="2.${sessionScope.user}中获取"></a>2.${sessionScope.user}中获取</h2><h3 id="6-向session里面添加数据"><a href="#6-向session里面添加数据" class="headerlink" title="6.向session里面添加数据"></a>6.向session里面添加数据</h3><p><strong>下面都是将模型数据绑定到session请求对象里面</strong></p>
<h4 id="6-1-原生的servlet方法"><a href="#6-1-原生的servlet方法" class="headerlink" title="6.1 原生的servlet方法"></a>6.1 原生的servlet方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/session"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">session</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        HttpSession httpSession=request.getSession();</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">        httpSession.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/session"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">session</span><span class="params">(HttpSession httpSession)</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">        httpSession.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-SessionAttributes注解"><a href="#6-2-SessionAttributes注解" class="headerlink" title="6.2 @SessionAttributes注解"></a>6.2 @SessionAttributes注解</h4><p>@SessionAttributes(value=”user”)<br>@SessionAttributes(types=User.class)<br>直接加在类前面，对每个方法都生效</p>
<p>作用：对每个方法，一旦 你向request里面加了一个key叫”user”的对象，它就会加入到session里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(value=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewhHandler</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-applicationScope-user-中获取"><a href="#3-applicationScope-user-中获取" class="headerlink" title="3.${applicationScope.user}中获取"></a>3.${applicationScope.user}中获取</h2><p>servletcontext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/application"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">application</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        ServletContext application=request.getServletContext();</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"谭天"</span>);</span><br><span class="line">        application.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<h1 id="自定义数据转化器"><a href="#自定义数据转化器" class="headerlink" title="自定义数据转化器"></a>自定义数据转化器</h1><p>数据转化器：是指把客户端http请求中的参数转化为业务方法中定义的形参</p>
<p>自定义表示，自己设计转换方式，虽然HandlerAdapter 提供了String转int/表单数据的封装</p>
<p>例子：String转Date<br>两个步骤</p>
<ul>
<li>写<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateConverter</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern=pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="keyword">this</span>.pattern);</span><br><span class="line">        Date date=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date=simpleDateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在springmvc.xml中配置 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置自定义转换器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.tt.converter.DateConverter"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//只改了1w第一行</span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span> <span class="attr">value</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>






</li>
</ul>
<h1 id="rest风格"><a href="#rest风格" class="headerlink" title="rest风格"></a>rest风格</h1><p>@Repository注解<br>给接口的实现类加上，交给IoC</p>
<p>restful风格  <a href="http://localhost:9090/rest/findById/1" target="_blank" rel="noopener">http://localhost:9090/rest/findById/1</a></p>
<p>例子：实现findById</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findbyid/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentRepository.findById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="springmvc的文件上传和下载"><a href="#springmvc的文件上传和下载" class="headerlink" title="springmvc的文件上传和下载"></a>springmvc的文件上传和下载</h1><h2 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h2><p>底层是使用fileupdate组件完成，springmvc只是封装了它</p>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>JSP</p>
<ul>
<li>必须是input的type是file</li>
<li>必须是method等于post</li>
<li>必须是enctype等于multipart/form-data<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/file/upload"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"file"</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>multi-part配置，为了解析这个文件<br>spring.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置上传组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileupload</span><span class="params">(MultipartFile img, HttpServletRequest request)</span></span>&#123;<span class="comment">//img不能为别的名字 因为是根据名字将请求中的参数转为形参</span></span><br><span class="line">        System.out.println(img);</span><br><span class="line">        <span class="comment">//保存到磁盘</span></span><br><span class="line">        <span class="keyword">if</span>(img.getSize()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            String path=request.getServletContext().getRealPath(<span class="string">"file"</span>);<span class="comment">//绝对路径</span></span><br><span class="line">            String name=img.getOriginalFilename();</span><br><span class="line">            File file=<span class="keyword">new</span> File(path,name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                img.transferTo(file);<span class="comment">//通过io</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>并且，如果要显示图片在前端<br>需要在web.xml里面设置，因为我们此时的路径是/file/1.png 无法识别是路径还是资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/download/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filedownload</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name, HttpServletRequest request, HttpServletResponse response)</span>&#123;<span class="comment">//img不能为别的名字 因为是根据名字将请求中的参数转为形参</span></span><br><span class="line">        <span class="keyword">if</span>(name!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            name+=<span class="string">".jpg"</span>;</span><br><span class="line">            String path=request.getServletContext().getRealPath(<span class="string">"file"</span>);</span><br><span class="line">            File file=<span class="keyword">new</span> File(path,name);</span><br><span class="line">            OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                response.setContentType(<span class="string">"application/forc-download"</span>);</span><br><span class="line">                response.setHeader(<span class="string">"Content-Disposition"</span>,<span class="string">"attachment;filename="</span>+name);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os=response.getOutputStream();</span><br><span class="line">                    os.write(FileUtils.readFileToByteArray(file));</span><br><span class="line">                    os.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(os!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            os.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java类加载机制</title>
    <url>/tantian123.github.io/2020/06/14/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="在同一个main方法里，不能访问main外面定义的成员变量"><a href="#在同一个main方法里，不能访问main外面定义的成员变量" class="headerlink" title="在同一个main方法里，不能访问main外面定义的成员变量"></a>在同一个main方法里，不能访问main外面定义的成员变量</h1><p>这是因为jvm的类加载机制<br>main方法是一个静态方法，而成员变量如果是非静态的话，它是在对象实例化之后才存在的，<br>而main静态方法是最早实例化的。</p>
]]></content>
  </entry>
  <entry>
    <title>一文了解生产者消费者模型</title>
    <url>/tantian123.github.io/2020/06/11/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>是多线程编程的经典模型</p>
<p>A进程和B进程共享一片固定大小的缓冲区<br>A进程产生数据放入缓冲区，B进程从缓冲区取出数据</p>
<h1 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h1><p>1.平衡生产者的生产能力和消费者的消费能力，从而提升效率<br>2.解耦</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>单生产者单消费者<br>多生产者多消费者</p>
<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>1.Object的wait() / notify()方法<br>2.Lock和Condition的await() / signal()方法<br>3.BlockingQueue阻塞队列方法<br>4.PipedInputStream / PipedOutputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>深入理解AIO/BIO/NIO</title>
    <url>/tantian123.github.io/2020/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AIO-BIO-NIO/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p>Synchronous/Asynchronous</p>
<ul>
<li>在没有得到结果之前,该调用就不返回</li>
<li>调用发出后,调用者不能立刻得到结果<h2 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h2>Blocking /Nonblocking</li>
<li>调用结果返回之前,当前线程会被挂起</li>
<li>不能立刻得到结果之前,该函数不会阻塞当前线程,而会立刻返回<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2></li>
</ul>
<p>1.从进程通信的层面考虑，阻塞和同步是一个意思<br>因为任意时刻，一个cpu上只有一个进程在运行</p>
<p>2.在IO系统调用层面<br><strong>同步和异步仅仅是关于所关注的消息如何通知的机制</strong><br>是程序自己去问，还是操作系统主动返回给程序（消息通知的形式）</p>
<p><strong>阻塞和非阻塞应该是发生在消息的处理的时刻</strong><br>如果未就绪，我是等还是不等（调用者自身的状态）</p>
<p>同步的实现方式：等待，轮询<br>单线程下，同步通过等待实现，等待其实就是串行执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(b());</span><br><span class="line">    <span class="comment">//只有b完成 才能继续</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//做一些耗时的工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4396</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多线程下，同步通过轮询实现，a不断询问标志位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">        System.out.println(<span class="number">4396</span>);<span class="comment">//一直询问</span></span><br><span class="line">    <span class="comment">//只有b完成 才能继续</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//其它线程</span></span><br><span class="line">    flag=<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的实现方式:回调函数</p>
<h2 id="BIO-blocking"><a href="#BIO-blocking" class="headerlink" title="BIO blocking"></a>BIO blocking</h2><p>传统的java.io包<br>包有 InputStream、OutputStream、Writer、Reader</p>
<p>同步阻塞的</p>
<h2 id="NIO-no-blocking-io-或者-new-io"><a href="#NIO-no-blocking-io-或者-new-io" class="headerlink" title="NIO   no-blocking io 或者 new io"></a>NIO   no-blocking io 或者 new io</h2><p>1.4引入的java.nio包<br>多路复用<br>提供了 Channel、Selector、Buffer 等新的抽象  通道 缓冲区 选择器</p>
<p>同步非阻塞的</p>
<h2 id="AIO-Asynchronous"><a href="#AIO-Asynchronous" class="headerlink" title="AIO   Asynchronous"></a>AIO   Asynchronous</h2><p>1.7引入的NIO的改进版 NIO 2 </p>
<p>异步非阻塞的</p>
<h1 id="NIO-BIO的比较"><a href="#NIO-BIO的比较" class="headerlink" title="NIO BIO的比较"></a>NIO BIO的比较</h1><p>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多。<br>BIO 是阻塞的，NIO 则是非阻塞的 。<br>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener">知乎-萧萧</a></p>
]]></content>
  </entry>
  <entry>
    <title>java迭代器的使用总结</title>
    <url>/tantian123.github.io/2020/06/10/java%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-为什么要迭代器"><a href="#1-为什么要迭代器" class="headerlink" title="1.为什么要迭代器"></a>1.为什么要迭代器</h1><p><strong>遍历容器内元素</strong><br>迭代器是一个对象，也是一种抽象，把访问逻辑从不同的集合类中抽取出来，不暴露内部结构。<br>从而在更换集合类型的时候，不需要修改原本的代码。</p>
<h1 id="2-迭代器定义："><a href="#2-迭代器定义：" class="headerlink" title="2.迭代器定义："></a>2.迭代器定义：</h1><h2 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h2><p>对Collection进行迭代的迭代器<br>在java.util.Iterator下</p>
<h2 id="Iteratable接口"><a href="#Iteratable接口" class="headerlink" title="Iteratable接口"></a>Iteratable接口</h2><p>实现这个接口的集合，是可迭代的<br>该接口的iterator()方法返回一个标准的Iterator实现</p>
<h1 id="3-迭代器的使用："><a href="#3-迭代器的使用：" class="headerlink" title="3.迭代器的使用："></a>3.迭代器的使用：</h1><p>iterator()方法，返回一个Iterator对象<br>hasNext ，判断迭代器是否还有下一个元素<br>next，获取迭代器的下一个元素，向后移动一个单位<br>remove，删除当前的迭代器所指向元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> List&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);list.add(<span class="string">"2"</span>);list.add(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size() ;  i++)&#123;</span><br><span class="line">    String string = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator=list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器在map的使用"><a href="#迭代器在map的使用" class="headerlink" title="迭代器在map的使用"></a>迭代器在map的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">"1"</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">"2"</span>);</span><br><span class="line">map.put(<span class="number">3</span>,<span class="string">"3"</span>);</span><br><span class="line">map.put(<span class="number">4</span>,<span class="string">"4"</span>);</span><br><span class="line"><span class="comment">//通过map的entry</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iterator=map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer,String&gt; entry=iterator.next();</span><br><span class="line">    entry.getKey();</span><br><span class="line">    entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h1 id="4-和其它遍历方式的区别"><a href="#4-和其它遍历方式的区别" class="headerlink" title="4.和其它遍历方式的区别"></a>4.和其它遍历方式的区别</h1><h2 id="和for循环的区别"><a href="#和for循环的区别" class="headerlink" title="和for循环的区别"></a>和for循环的区别</h2><p>如果是Arraylist集合，随机访问快，使用get方法<br>如果是Linkedlist集合，顺序访问快，使用迭代器</p>
<h2 id="和for-each的区别"><a href="#和for-each的区别" class="headerlink" title="和for each的区别"></a>和for each的区别</h2><p>for each内部是迭代器实现的<br>只是为了代码简洁和使用方便。</p>
<h1 id="5-可能出现的问题"><a href="#5-可能出现的问题" class="headerlink" title="5.可能出现的问题"></a>5.可能出现的问题</h1><h2 id="ConcurrentModificationException异常-fail-fast机制"><a href="#ConcurrentModificationException异常-fail-fast机制" class="headerlink" title="ConcurrentModificationException异常(fail-fast机制)"></a>ConcurrentModificationException异常(fail-fast机制)</h2><p>如果一边遍历集合，一边删除元素，就会出现这个异常</p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>报错的是checkForComodification()方法，它会验证modCount的值和expectedModCount的值是否相等<br>modCount记录对象被修改的次数，创建迭代器的时候，expectedModCount=modCount<br>之后如果修改了，modCount++，而expectedModCount不变，二者不等，于是报错。</p>
<p>保证在遍历集合的过程中，集合不会产生结构的改变。</p>
<h3 id="如何解决："><a href="#如何解决：" class="headerlink" title="如何解决："></a>如何解决：</h3><p>单线程：<br>把需要删除的对象保存到一个集合中，等遍历结束之后再调用removeAll()方法来删除<br>多线程：<br>使用ConcurrentHashMap和CopyOnWriteArrayList<br>CopyOnWriteArrayList是在副本上操作。</p>
<h1 id="6-迭代器设计模式"><a href="#6-迭代器设计模式" class="headerlink" title="6.迭代器设计模式"></a>6.迭代器设计模式</h1><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
]]></content>
      <tags>
        <tag>-java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录及cookie和session</title>
    <url>/tantian123.github.io/2020/06/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8F%8Acookie%E5%92%8Csession/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u011277123/article/details/53404269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">参考</a></p>
<h1 id="HTTP是无状态协议"><a href="#HTTP是无状态协议" class="headerlink" title="HTTP是无状态协议"></a>HTTP是无状态协议</h1><h1 id="1-cookie-通行证"><a href="#1-cookie-通行证" class="headerlink" title="1.cookie 通行证"></a>1.cookie 通行证</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>服务器如果要记录客户端的状态，就会在response中加上一个cookie给客户端，客户端浏览器将cookie保存<br>该浏览器再次请求该网站时，就会在请求中加上cookie，服务器以此来辨认用户状态。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>客户端发送HTTP request </li>
<li>服务器返回HTTP response + cookie</li>
<li>客户端发送HTTP request + cookie</li>
<li>服务器返回HTTP response</li>
</ul>
<h2 id="cookie的不可跨域名性"><a href="#cookie的不可跨域名性" class="headerlink" title="cookie的不可跨域名性"></a>cookie的不可跨域名性</h2><p>google的cookie不能用在baidu上</p>
<h1 id="2-session-会话"><a href="#2-session-会话" class="headerlink" title="2.session 会话"></a>2.session 会话</h1><p>session保存在服务器上，cookie保存在客户端浏览器上<br>相应的，服务器压力也会增大</p>
<p>只有访问servlet和JSP时才会产生session，只访问html等静态资源不会产生session<br>在javax.servlet.http.HttpSession包下。</p>
<ul>
<li>用户登录成功后，服务器创建一个session保存在服务器</li>
<li>生成唯一的key即sessionid返回给客户端，sessionid保存在cookie中</li>
<li>客户端访问会带上sessionid</li>
</ul>
<h1 id="3-token-令牌"><a href="#3-token-令牌" class="headerlink" title="3.token 令牌"></a>3.token 令牌</h1><p>格式：uid+time+sign[+固定参数]<br>uid 用户的唯一标识<br>time 当前的时间戳<br>sign 签名，为了保证安全性</p>
<h2 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h2><p>用户登录成功，服务器生成token，服务器保存token到数据库，再返回这个token给客户端<br>客户端拿到token保存在本地<br>客户端再次发送网络请求时，就会把token附带到请求中<br>服务器收到后，与本地的token进行对比</p>
<h2 id="token和session的对比"><a href="#token和session的对比" class="headerlink" title="token和session的对比"></a>token和session的对比</h2><h1 id="4-单点登录"><a href="#4-单点登录" class="headerlink" title="4.单点登录"></a>4.单点登录</h1><p>概念：<br>单点登录 Single Sign On<br>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统</p>
<p>SSO有一个独立的认证中心，只有认证中心能接收用户名，密码。<br>其它系统只能接收认证中心的间接授权</p>
<p>与认证中心的会话为全局会话，与其它系统的会话是局部会话。<br>全局会话注销，局部会话必须注销。</p>
<h2 id="4-1-如何实现单点登录-基于java的实现"><a href="#4-1-如何实现单点登录-基于java的实现" class="headerlink" title="4.1.如何实现单点登录 基于java的实现"></a>4.1.如何实现单点登录 基于java的实现</h2><p>C/S架构</p>
<p>sso-client与sso-server ，sso-server 就是认证中心</p>
<h3 id="sso-client"><a href="#sso-client" class="headerlink" title="sso-client"></a>sso-client</h3><p>拦截子系统未登录用户请求，跳转至sso认证中心<br>接收并存储sso认证中心发送的令牌<br>与sso-server通信，校验令牌的有效性<br>建立局部会话<br>拦截用户注销请求，向sso认证中心发送注销请求<br>接收sso认证中心发出的注销请求，销毁局部会话</p>
<h3 id="sso-server"><a href="#sso-server" class="headerlink" title="sso-server"></a>sso-server</h3><p>验证用户的登录信息<br>创建全局会话<br>创建授权令牌<br>与sso-client通信发送令牌<br>校验sso-client令牌有效性<br>系统注册<br>接收sso-client注销请求，注销所有会话</p>
<h1 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h1><p>权限管理<br>通过拦截器或者过滤器<br>Shiro权限管理框架</p>
<p>OAuth2.0</p>
<p>例子：登录wegame，通过qq快速登录<br>Client           wegame<br>Resource Owner   qq号的所有者<br>Authorization Server  qq服务器<br>Resource Server   qq服务器<br><img src="https://img-blog.csdnimg.cn/20190723094240783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VUVFRUVFNT,size_16,color_FFFFFF,t_70" alt="image"><br>流程：wegame请求qq号的所有者授权，</p>
]]></content>
  </entry>
  <entry>
    <title>一篇了解所有编码格式</title>
    <url>/tantian123.github.io/2020/06/10/%E4%B8%80%E7%AF%87%E4%BA%86%E8%A7%A3%E6%89%80%E6%9C%89%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h1><p>ASCII 外国人最开始用的<br>GB2312 ASCII的中国扩展，为了支持中文<br>GBK    GB2312的扩展，加了一些文字</p>
<p>UNICODE 最后的统一，ISO为了统一编码格式<br>UTF8    为了网络传输发明的，是一次8位的UNICODE，UTF-8是Unicode的实现方式之一  </p>
]]></content>
  </entry>
  <entry>
    <title>java爬虫1</title>
    <url>/tantian123.github.io/2020/06/09/java%E7%88%AC%E8%99%AB1/</url>
    <content><![CDATA[<p>URL类<br>URLConnections 类</p>
<p>HttpClient<br>相比于传统的JDK自带的URLConnection，更加简单</p>
<p>使用方式<br>1.创建 CloseableHttpClient对象或CloseableHttpAsyncClient对象，前者同步，后者为异步<br>2.创建Http请求对象(GET PUT POST DELETE) 参数是URL<br>带参数的请求可以通过uribuilder来创建，通过setParameter设置uri的参数</p>
<p>3.调用execute方法执行请求，如果是异步请求在执行之前需调用start方法<br>4.关闭response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CloseableHttpClient httpClient = HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET不带参数</span></span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost:8888/doGetControllerOne"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET带参数</span></span><br><span class="line"><span class="comment">//http://localhost:8888/doGetControllerOne?keys=Java</span></span><br><span class="line">URIBuilder uribuilder=<span class="keyword">new</span> URIBuilder(<span class="string">"http://localhost:8888/doGetControllerOne"</span>);</span><br><span class="line">uribuilder.setParameter(<span class="string">"keys"</span>,<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(uribuilder.build());</span><br><span class="line"></span><br><span class="line"><span class="comment">//post  不带参数只需要把httpset改为httppost</span></span><br><span class="line">HttpPost httpPost = <span class="keyword">new</span> HttpPost(uribuilder.build());</span><br><span class="line"><span class="comment">//post 带参数 url地址中无参数，参数在表单中</span></span><br><span class="line"><span class="comment">//1.声明list集合，封装表单参数</span></span><br><span class="line"><span class="comment">//2.创建表单的Entity对象</span></span><br><span class="line"><span class="comment">//3.设置表单的Entity对象到POST请求中</span></span><br><span class="line">List&lt;NameValuePair&gt; params=<span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"keys"</span>,<span class="string">"java"</span>));</span><br><span class="line"></span><br><span class="line">UrlEncodeFormEntity formEntity=<span class="keyword">new</span> UrlEncodeFormEntity(params,<span class="string">"utf8"</span>);</span><br><span class="line">httpPost.setEntity(formEntity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************/</span></span><br><span class="line"></span><br><span class="line">CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">response = httpClient.execute(httpGet);</span><br><span class="line"></span><br><span class="line">HttpEntity responseEntity = response.getEntity();</span><br><span class="line">System.out.println(<span class="string">"响应状态为:"</span> + response.getStatusLine());</span><br><span class="line">System.out.println(<span class="string">"响应码:"</span> + response.getStatusLine().getStatusCode());</span><br><span class="line">System.out.println(<span class="string">"响应内容长度为:"</span> + responseEntity.getContentLength());</span><br><span class="line">System.out.println(<span class="string">"响应内容为:"</span> + EntityUtils.toString(responseEntity));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/doGetControllerOne"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doGetControllerOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>其它优化<br>使用连接池 </p>
<h1 id="爬虫框架webmagic"><a href="#爬虫框架webmagic" class="headerlink" title="爬虫框架webmagic"></a>爬虫框架webmagic</h1><p>有核心和扩展两个部分</p>
<p>四大组件：<br>downloader pageprocessor scheduler pipeline<br>下载 处理 管理 持久化（输出）<br>并且用spider将它们组合起来</p>
<p>对象：<br>1.request<br>对url进行封装<br>pageprocessor控制downloader的方式<br>2.page<br>downloader下载的页面<br>3.ResultItems<br>是一个类似map，存储pageprocessor的结果，提供给pipeline</p>
]]></content>
  </entry>
  <entry>
    <title>springboot学习1</title>
    <url>/tantian123.github.io/2020/06/07/springboot%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="helloworld快速创建"><a href="#helloworld快速创建" class="headerlink" title="helloworld快速创建"></a>helloworld快速创建</h1><p>通过IDEA  Spring Initializr 自动完成基础项目的创建<br>1.启动类<br>2.application.properties配置文件<br>3.测试类<br>4.pom.xml</p>
<h2 id="pom-xml查看依赖"><a href="#pom-xml查看依赖" class="headerlink" title="pom.xml查看依赖"></a>pom.xml查看依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web场景启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springboot单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 剔除依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 打包插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写http接口"><a href="#编写http接口" class="headerlink" title="编写http接口"></a>编写http接口</h2><p>在启动类同级目录下建立controller层<br>新建hellocontroller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;<span class="comment">//访问http://localhost:9090/hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动类分析"><a href="#启动类分析" class="headerlink" title="启动类分析"></a>启动类分析</h2><p>@SpringBootApplication<br>标注这是springboot的主类，运行这个类的main方法</p>
<p>SpringApplication.run(DemoApplication.class, args);<br>1.SpringApplication的实例化<br>2.run方法的执行<br>这个类做了以下工作（查看其构造函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances();</span><br><span class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断项目类型</li>
<li>查找并加载所有初始化器</li>
<li>找出所有的监听器</li>
<li>找到运行的主类</li>
</ul>
<h2 id="springboot的配置文件"><a href="#springboot的配置文件" class="headerlink" title="springboot的配置文件"></a>springboot的配置文件</h2><p>1.两种类型</p>
<ul>
<li>application.properties<br>语法结构 ：key=value</li>
<li>application.yml<br>语法结构 ：key：空格 value</li>
</ul>
<p>2.作用：修改springboot的基础配置，例如端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种</span><br><span class="line">server.port=8081</span><br><span class="line"></span><br><span class="line">//第二种</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br></pre></td></tr></table></figure>
<p>3.区别<br>yaml是天然的树状结构 编写时可以省去相同的部分</p>
]]></content>
  </entry>
  <entry>
    <title>PriorityQueue使用</title>
    <url>/tantian123.github.io/2020/06/06/PriorityQueue%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>PriorityQueue优先队列<br>//满了之后，并不会自动替换元素</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>每次都能保证取出的元素是队列中权值最小的<br>可以通过comparator接口，实现排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>add offer  插入元素<br>element peek  获取队首<br>remove poll  删除队首并返回</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用构造函数</span></span><br><span class="line">PriorityQueue()</span><br><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)<span class="comment">//初始容量，指定的比较器</span></span><br></pre></td></tr></table></figure>


<p>使用匿名内部类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/tantian123.github.io/2020/06/05/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="什么是泛型-generic"><a href="#什么是泛型-generic" class="headerlink" title="什么是泛型  generic"></a>什么是泛型  generic</h1><p>将具体的类型参数化<br>只在编译期间有效，随后编译器会用具体的类型来代替它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//泛型加在类名的后面，&lt;&gt;里面的就是形参 一般写大写字母</span></span><br><span class="line">    <span class="comment">//可以定义多个 之间用逗号隔开</span></span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定,</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="为什么要泛型"><a href="#为什么要泛型" class="headerlink" title="为什么要泛型"></a>为什么要泛型</h1><p>早期java是没有泛型的，用Object类</p>
<p>泛型的作用是在编译期帮助发现错误并且增强可读性</p>
<ul>
<li>不需要强制转换，交给了编译器</li>
<li>编写时，就限制了类型 ，提高了代码可读性和稳定性</li>
</ul>
<h1 id="泛型是如何工作的-类型擦除"><a href="#泛型是如何工作的-类型擦除" class="headerlink" title="泛型是如何工作的  类型擦除"></a>泛型是如何工作的  类型擦除</h1><p>编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息</p>
<p>没有使用时，默认为Object类型</p>
]]></content>
  </entry>
  <entry>
    <title>java异常</title>
    <url>/tantian123.github.io/2020/06/05/java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h1><p>异常是发生在程序执行过程中阻碍程序正常执行的错误事件（阻碍正常运行的事件）</p>
<p>只要在Java语句执行中产生了异常，一个异常对象就会被创建，JRE就会试图寻找异常处理程序来处理异常。</p>
<h1 id="Java异常的分类"><a href="#Java异常的分类" class="headerlink" title="Java异常的分类"></a>Java异常的分类</h1><p>Throwable为顶层父类<br>Throwable分为Error类和Exception类。<br>Error类：程序无法处理的严重错误，我们不作处理，与操作者无关。如系统崩溃，内存不足，堆栈溢出等<br>Exception —— 异常：异常可以分为运行时异常和编译期异常</p>
<ul>
<li>RuntimeException及其子类：即运行时异常，不会被编译器所检测出来，我们必须修正代码。</li>
<li>非RuntimeException及其子类：即编译期异常，必须处理，否则程序编译无法通过。</li>
</ul>
<p>区别就是一个编译能通过，一个编译通不过。</p>
<p><img src="/images/throwable.jpg" alt="throwable"></p>
<h1 id="检查型异常和非检查型异常"><a href="#检查型异常和非检查型异常" class="headerlink" title="检查型异常和非检查型异常"></a>检查型异常和非检查型异常</h1><p>检查型异常  非RuntimeException及其子类<br>非检查型异常  Error类和RuntimeException及其子类</p>
<h1 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h1><p>try…catch…finally语句块<br>throws函数声明</p>
<p>特别的是：如果catch中有return语句，那么finally会在return执行之前执行。</p>
<h1 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h1><p>throw是语句抛出一个异常<br>throws是声明 方法可能抛出的异常</p>
<h1 id="final-finalize-finally关键字的区别"><a href="#final-finalize-finally关键字的区别" class="headerlink" title="final,finalize,finally关键字的区别"></a>final,finalize,finally关键字的区别</h1><p>首先，finalize是方法<br>final,finally是关键字<br>final修饰类、变量、方法 表示不能再继承/赋值/重写<br>finall用于异常处理代码块<br>finalize是Object类的方法，<br>在垃圾收集器执行的时候会调用被回收对象的finalize（）方法<br>实现资源的回收。</p>
<h1 id="如何自定义异常"><a href="#如何自定义异常" class="headerlink" title="如何自定义异常"></a>如何自定义异常</h1><p>创建自定义类继承Exception类<br>在方法中通过throw抛出异常<strong>对象</strong></p>
]]></content>
  </entry>
  <entry>
    <title>java除法和取模</title>
    <url>/tantian123.github.io/2020/06/05/java%E9%99%A4%E6%B3%95%E5%92%8C%E5%8F%96%E4%BD%99/</url>
    <content><![CDATA[<h1 id="取余和取模的区别"><a href="#取余和取模的区别" class="headerlink" title="取余和取模的区别"></a>取余和取模的区别</h1><p><strong>各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。</strong></p>
<p>取余，遵循尽可能让商向0靠近的原则<br>取模，遵循尽可能让商向负无穷靠近的原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于式子<span class="number">10</span>%-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">c++/java为 -<span class="number">3</span>  ...<span class="number">1</span><span class="comment">//取余</span></span><br><span class="line">python为   -<span class="number">4</span>  ...-<span class="number">2</span><span class="comment">//取模</span></span><br></pre></td></tr></table></figure>

<h1 id="java中的取余和取模"><a href="#java中的取余和取模" class="headerlink" title="java中的取余和取模"></a>java中的取余和取模</h1><p>Java 中的取余运算是 %，而取模运算是 Math.floorMod()</p>
<p><strong>取余运算的符号是根据第一个运算数决定的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">System.out.println(<span class="number">7</span> % <span class="number">4</span>);<span class="comment">//3</span></span><br><span class="line">System.out.println((-<span class="number">7</span>) % <span class="number">4</span>);<span class="comment">//-3</span></span><br><span class="line">System.out.println(<span class="number">7</span> % (-<span class="number">4</span>));<span class="comment">//3</span></span><br><span class="line">System.out.println((-<span class="number">7</span>) % (-<span class="number">4</span>));<span class="comment">//-3</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Integer相关知识</title>
    <url>/tantian123.github.io/2020/06/05/Integer%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Integer类详解"><a href="#Integer类详解" class="headerlink" title="Integer类详解"></a>Integer类详解</h1><p>基本数据类型  boolean、byte、int、char、long、short、double、float<br>引用数据类型  数组、类、接口<br>Integer是类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Integer重写了hashCode方法，返回值是value-即Integer对象-的数值。"><a href="#Integer重写了hashCode方法，返回值是value-即Integer对象-的数值。" class="headerlink" title="Integer重写了hashCode方法，返回值是value,即Integer对象 的数值。"></a>Integer重写了hashCode方法，返回值是value,即Integer对象 的数值。</h1><h1 id="Integer重写了equals方法-比较值-比较地址"><a href="#Integer重写了equals方法-比较值-比较地址" class="headerlink" title="Integer重写了equals方法 比较值   ==比较地址"></a>Integer重写了equals方法 比较值   ==比较地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        if (obj instanceof Integer) &#123;</span><br><span class="line">            return value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Integer-类和-int-的区别"><a href="#Integer-类和-int-的区别" class="headerlink" title="Integer 类和 int 的区别"></a>Integer 类和 int 的区别</h2><p>1.Integer是类型和int是基本数据类型<br>2.Integer默认值是null int默认值是0<br>3.Integer实际是对象的引用，而int则是直接存储数据值<br>4.baiInteger变量必须实例化后才能使用，而int变量不需要</p>
<h1 id="开箱和装箱"><a href="#开箱和装箱" class="headerlink" title="开箱和装箱"></a>开箱和装箱</h1><p>自动装箱和拆箱<br>在编译期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer a = <span class="number">128</span>;</span><br><span class="line">编译器转换为</span><br><span class="line">Integer a = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">int</span> b=a;</span><br><span class="line">编译器转换为</span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">int</span> b = a.intValue();</span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存只能在自动装箱或者是调用Integer.valueOf(int x)才会有用。</p>
<p>缓存的范围byte&lt;= 127、char&lt;=127、-128&lt;=short &lt;=127、-128&lt;=int &lt;=127</p>
<p>所有就有这么一道题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">127</span>;  </span><br><span class="line">Integer i2 = <span class="number">127</span>;  </span><br><span class="line">System.err.println(i1 == i2);  <span class="comment">//true</span></span><br><span class="line">      </span><br><span class="line">Integer i1 = <span class="number">128</span>;  </span><br><span class="line">Integer i2 = <span class="number">128</span>;  </span><br><span class="line">System.err.println(i1 == i2);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line">System.err.println(i3 == i4);  <span class="comment">//false</span></span><br><span class="line">System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>Comparable和Comparator</title>
    <url>/tantian123.github.io/2020/06/04/Comparable/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>Comparable<br>Comparator</p>
<h1 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h1><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>为了排序</p>
<p>Comparator位于包java.util下，而Comparable位于包java.lang下</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承该接口，需要重写compareTo()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age()-p.age;<span class="comment">//比较的依据就是返回值是 大于0/小于0/等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Person&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.sort(arr);</span><br></pre></td></tr></table></figure>







<p>Comparator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>何时使用Comparator?<br>不改变类的原样，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.sort(<span class="keyword">new</span> PersonComparator());</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>hashmap原理</title>
    <url>/tantian123.github.io/2020/06/04/hashmap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="hashmap是什么"><a href="#hashmap是什么" class="headerlink" title="hashmap是什么"></a>hashmap是什么</h1><p>继承自Map<br>有一个数组，每个元素是一个桶，桶里面的可能是链表或者红黑树</p>
<p>O(1)的平均查找 插入 删除 时间 即常数时间的查找插入删</p>
<p>致命的是哈希碰撞</p>
<h1 id="1-8做了哪些优化"><a href="#1-8做了哪些优化" class="headerlink" title="1.8做了哪些优化"></a>1.8做了哪些优化</h1><p>1.数组+链表-&gt;数组+链表/红黑树<br>目的是为了避免链表过长，退化。<br>2.链表的插入：由头插变为尾插<br>目的是避免多线程下成环，从而陷入无限循环<br>3.1.7是先扩容再插入，1.8是先插入，后扩容</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>略</p>
<h2 id="初始参数"><a href="#初始参数" class="headerlink" title="初始参数"></a>初始参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//默认的初始容量必须是2的幂</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">//默认负载因子 扩容使用</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//TREEIFY树化的阈值</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br></pre></td></tr></table></figure>
<h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//存储元素的数组 transient表示不可序列化</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">//元素数量</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure>


<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)<br>这是扰动函数，key.hashCode()调用了自带的hash函数,返回的是int类型的整数，它的范围很大，但是数组大小初始只有16（节省内存），所以要先进行处理<br><strong>即把散列值和数组长度做一个”与”操作</strong>，如下：</p>
<blockquote>
<p>原理：在我们插入元素的时候,即在putVal函数中，<br>有tab[i = (n - 1) &amp; hash]<br>数组长度n-1得到的结果的二进制低位都是1（因为数组长度n是2的幂，假设是16，则为00000000 00000000 00001111）<br>与散列值做&amp;操作，相当于截取了最后四位<br>但是，如果你只是做了hash，截取最后四位的碰撞会很严重，这时就需要扰动函数</p>
</blockquote>
<p><img src="/images/hash.jpg" alt="hash"><br>高16位和低16位做异或，是为了混合原始哈希码的高位和低位，减少了碰撞的可能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="comment">//让hashcode的高16位和低16位进行异或操作</span></span><br><span class="line">        <span class="comment">//目的：一定要尽可能降低hash碰撞，越分散越好</span></span><br><span class="line">    &#125;</span><br><span class="line">  ```  </span><br><span class="line">#### put</span><br><span class="line"><span class="number">1</span>.判断插入的元素是否为空</span><br><span class="line">为空，初始化</span><br><span class="line">不为空，计算index</span><br><span class="line"><span class="number">2</span>.判断index处是否为空</span><br><span class="line">为空，创建Node</span><br><span class="line">不为空，即此时发生了hash冲突</span><br><span class="line"><span class="number">3</span>.判断key是否相同</span><br><span class="line">相同，替换</span><br><span class="line">不相同，下一步。</span><br><span class="line"><span class="number">3</span>.判断是否是树形</span><br><span class="line">是树形，调用红黑树的插入方法</span><br><span class="line">不是树形，即链表，使用链表的插入方法</span><br><span class="line"><span class="number">4</span>.插入后，判断是否需要扩容（大于阈值）</span><br><span class="line">扩容为<span class="number">2</span>倍</span><br><span class="line">``` java</span><br><span class="line"><span class="comment">//计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="comment">//让hashcode的高16位和低16位进行异或操作</span></span><br><span class="line">        <span class="comment">//目的：一定要尽可能降低hash碰撞，越分散越好</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用putVal，四个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putVal详解</span></span><br><span class="line"><span class="comment">//tab是哈希数组 p是首节点 n是哈希map的长度 i是计算的下标</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//判断是否为空，为空就初始化</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//不为空，计算位置(n - 1) &amp; hash</span></span><br><span class="line">        <span class="comment">//当前数组的index位置为空，就创建一个Node</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//当前数组的index位置不为空，就说明此时发生了hash冲突</span></span><br><span class="line">            <span class="comment">//然后判断key是否相同</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//key相同 ，替换原来的value</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果不相同，且为树型节点，即当前位置是红黑树，调用插入红黑树的方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果不相同，且不为树型节点，创建普通的Node加入当前位置的链表，此时还要判断，判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用getNode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tab哈希数组 first是头结点 e是临时变量 n是长度 k是key</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>何时触发扩容<br>putVal函数中有</p>
<blockquote>
<p>if ((tab = table) == null || (n = tab.length) == 0)<br>n = (tab = resize()).length;<br>和<br>if (++size &gt; threshold)<br>resize();<br>两处调用了resize，第一处是初始化table，第二处是table大小大于阈值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//原table不为空，即不是初始化的时候</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//超过最大扩容，就不扩了</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 左移一位，扩容二倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 构造函数指定了初始化默认容量</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 构造函数没有指定初始化默认容量，则大小为16</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是移动原来的table到扩容后的新的table</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果只有一个Node，直接移过去</span></span><br><span class="line">                    <span class="comment">//如果是红黑树，调用红黑树的方法</span></span><br><span class="line">                    <span class="comment">//如果是链表，则</span></span><br><span class="line">                    <span class="comment">//定义loTail hiTail两个链表</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//是一个do-while循环，就是遍历</span></span><br><span class="line">                        <span class="comment">//如果是(e.hash &amp; oldCap) == 0，放入loTail</span></span><br><span class="line">                        <span class="comment">//否则，放入hiTail</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//loTail放到新table即newTab[j]</span></span><br><span class="line">                        <span class="comment">//hiTail放到新table即newTab[j + oldCap]</span></span><br><span class="line">                        <span class="comment">//综上，就是拆为两个表，按照(e.hash &amp; oldCap) == 0的标准</span></span><br><span class="line">                        <span class="comment">//分析在下面</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对(e.hash &amp; oldCap) == 0和j + oldCap的理解<br>在于扩容前的oldCap和扩容后的newCap，newCap是两倍的oldCap<br>前面讲到的(n-1)&amp;hash,化为二进制的话，oldCap/newCap的低位是部分相同的<br>假设oldCap是16，则newCap是32，二者&amp;hash，一个是取后4位，一个是取后5位<br>那么从旧的index值，我们可以通过下面的方式，快速得到新的index值<br>即hash &amp;0000 0000 0000 0000 0000 0000 0001 0000<br>也就是等价于e.hash &amp; oldCap</p>
</blockquote>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="默认容量-负载因子-阈值"><a href="#默认容量-负载因子-阈值" class="headerlink" title="默认容量 负载因子 阈值"></a>默认容量 负载因子 阈值</h2><p>阈值=容量*负载因子</p>
<h2 id="变为树的阈值为什么是8"><a href="#变为树的阈值为什么是8" class="headerlink" title="变为树的阈值为什么是8"></a>变为树的阈值为什么是8</h2><p>hash冲突是符合泊松分布的, 而冲突概率最小的是在7-8之间<br>桶中的元素符合参数为0.5的泊松分布<br>泊松分布为8的时候，冲突的概率接近0</p>
<h2 id="数组的大小为什么是2的幂"><a href="#数组的大小为什么是2的幂" class="headerlink" title="数组的大小为什么是2的幂"></a>数组的大小为什么是2的幂</h2><p><strong>重点是求index</strong></p>
<p>目的就是为了得到高地址为0，低地址全1的值，因为index计算公式是h &amp; (length-1)<br>2的幂-1全是1，再与h进行&amp;操作，就得到h的最后几位<br>//如果不是2的幂，那么就会使两种不同的h 得到相同的尾数<br>//增加了碰撞的概率</p>
<h2 id="扩容是如何实现的"><a href="#扩容是如何实现的" class="headerlink" title="扩容是如何实现的"></a>扩容是如何实现的</h2><h2 id="rehash的作用是什么"><a href="#rehash的作用是什么" class="headerlink" title="rehash的作用是什么"></a>rehash的作用是什么</h2><p>长度变了，hash的规则也要变</p>
<h2 id="为什么是线程不安全的"><a href="#为什么是线程不安全的" class="headerlink" title="为什么是线程不安全的"></a>为什么是线程不安全的</h2><p>脏读</p>
<h2 id="1-7-1-8的改进，为什么要这样子"><a href="#1-7-1-8的改进，为什么要这样子" class="headerlink" title="1.7 1.8的改进，为什么要这样子"></a>1.7 1.8的改进，为什么要这样子</h2><h2 id="为什么重写equals方法需要重写hashCode方法"><a href="#为什么重写equals方法需要重写hashCode方法" class="headerlink" title="为什么重写equals方法需要重写hashCode方法"></a>为什么重写equals方法需要重写hashCode方法</h2><p>为了保证相同的对象返回相同的hash值，不同的对象返回不同的hash值</p>
]]></content>
  </entry>
  <entry>
    <title>密码学复习</title>
    <url>/tantian123.github.io/2020/06/03/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>dubbo第一次使用</title>
    <url>/tantian123.github.io/2020/06/03/dubbo%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-dubbo介绍"><a href="#1-dubbo介绍" class="headerlink" title="1.dubbo介绍"></a>1.dubbo介绍</h1><p>是一个高性能的java RPC框架</p>
<p>解决了分布式系统中互相调用的问题，但是没有调度中心</p>
<h2 id="rpc的过程："><a href="#rpc的过程：" class="headerlink" title="rpc的过程："></a>rpc的过程：</h2><p>最耗时的步骤：序列化和网络通信</p>
<p>本地的对象要在网路上传输，必须实现Serializable接口，即序列化<br>序列化的方式：二进制流，xml，json<br>显而易见，二进制流是效率最高的，而dubbo采用的就是二进制流</p>
<p>网路通信：<br>dubbo使用socket，不采用HTTP，不需要三次握手和四次挥手<br>并且是长连接</p>
<h2 id="三大核心功能"><a href="#三大核心功能" class="headerlink" title="三大核心功能"></a>三大核心功能</h2><p>面向接口的远程方法调用，智能容错和负载均衡 以及服务自动注册和发现</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>provider服务提供者<br>consumer服务消费者<br>container 容器<br>registry 注册中心<br>monitor监控中心 </p>
<p>除了monitor，都需要我们自己去写</p>
<h1 id="2-dubbo的直连使用"><a href="#2-dubbo的直连使用" class="headerlink" title="2.dubbo的直连使用"></a>2.dubbo的直连使用</h1><p>直连：即不使用注册中心，不从注册中心获取地址</p>
<h2 id="2-1服务端"><a href="#2-1服务端" class="headerlink" title="2.1服务端"></a>2.1服务端</h2><h4 id="1-配置maven依赖"><a href="#1-配置maven依赖" class="headerlink" title="1.配置maven依赖"></a>1.配置maven依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.tt&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-interface&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.8&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.1.32.Final&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-接口类"><a href="#2-接口类" class="headerlink" title="2.接口类"></a>2.接口类</h4><p>对外提供服务的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-接口实现类"><a href="#3-接口实现类" class="headerlink" title="3.接口实现类"></a>3.接口实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-dubbo核心配置文件-作用是暴露接口"><a href="#4-dubbo核心配置文件-作用是暴露接口" class="headerlink" title="4.dubbo核心配置文件 作用是暴露接口"></a>4.dubbo核心配置文件 作用是暴露接口</h4><ul>
<li>1.服务提供者声明名称，dubbo内部唯一的标识  </li>
<li>2.访问服务协议名和端口号 </li>
<li>3.暴露服务接口（接口路径+实现类）</li>
<li>4.为了实现上一步，将接口的实现类加载到spring bean容器中<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    服务提供者声明名称，保证名称的唯一--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"userservice-provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    访问服务协议的名称和端口号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    服务发布的配置，需要暴露的服务接口   registry="N/A"说明是直连的方式 ref后面是在spring容器中的标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.tt.dubbo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"userService"</span> <span class="attr">registry</span>=<span class="string">"N/A"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    将接口的实现类加载到容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.tt.dubbo.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-Provider类-发布接口"><a href="#5-Provider类-发布接口" class="headerlink" title="5.Provider类 发布接口"></a>5.Provider类 发布接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"dubbo-provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-运行-Provider类的结果"><a href="#6-运行-Provider类的结果" class="headerlink" title="6.运行 Provider类的结果"></a>6.运行 Provider类的结果</h4><p>暴露出来的url 也是一个类似http的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo://192.168.139.1:20880/com.tt.dubbo.DemoService?anyhost=true&amp;application=userservice-provider&amp;bean.name=com.tt.dubbo.DemoService&amp;bind.ip=192.168.139.1&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.tt.dubbo.DemoService&amp;methods=sayHello&amp;pid=1340&amp;side=provider&amp;timestamp=1593594139503</span><br></pre></td></tr></table></figure>
<p>我们这里采用点对点的方式，所以，需要在消费者端配置在服务端暴露的url </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo://192.168.139.1:20880/com.tt.dubbo.DemoService</span><br></pre></td></tr></table></figure>

<h2 id="2-消费者端"><a href="#2-消费者端" class="headerlink" title="2.消费者端"></a>2.消费者端</h2><h4 id="1-配置maven依赖-1"><a href="#1-配置maven依赖-1" class="headerlink" title="1.配置maven依赖"></a>1.配置maven依赖</h4><p>同上，并且导入服务类的jar包</p>
<h4 id="2-dubbo核心配置文件"><a href="#2-dubbo核心配置文件" class="headerlink" title="2.dubbo核心配置文件"></a>2.dubbo核心配置文件</h4><ul>
<li>声明消费者名称，唯一的</li>
<li>引用之前定义的远程服务接口<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer"</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"com.tt.dubbo.DemoService"</span> <span class="attr">url</span>=<span class="string">"dubbo://192.168.139.1:20880/com.tt.dubbo.DemoService"</span> <span class="attr">registry</span>=<span class="string">"N/A"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-运行"><a href="#3-运行" class="headerlink" title="3.运行"></a>3.运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"dubbo-provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="3-使用注册中心连接"><a href="#3-使用注册中心连接" class="headerlink" title="3.使用注册中心连接"></a>3.使用注册中心连接</h1><p>上一节，我们没有使用注册中心，是使用直连的方法，接下来会使用zookeeper+dubbo的方式，对以上代码进行改造</p>
<p>zookeeper作为注册中心，采用的是cp的思想</p>
<h2 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1.服务端"></a>1.服务端</h2><p>只需要修改 provider.xml 即可。</p>
<p>&lt;dubbo:registry address=”zookeeper://localhost:2181” /&gt;</p>
<h2 id="2-消费者端-1"><a href="#2-消费者端-1" class="headerlink" title="2.消费者端"></a>2.消费者端</h2><p>只需要修改 consumer.xml 即可。</p>
<p>&lt;dubbo:registry address=”zookeeper://localhost:2181”/&gt;</p>
<p>不是点对点了，修改这里<br>&lt;dubbo:reference id=”providerService”<br>                     interface=”com.sihai.dubbo.provider.service.ProviderService”/&gt;</p>
<h1 id="4-多种配置方式"><a href="#4-多种配置方式" class="headerlink" title="4.多种配置方式"></a>4.多种配置方式</h1><p>之前使用的配置方式是xml，我们还可以使用的方式有：<br>API配置方式<br>注解配置方式</p>
]]></content>
  </entry>
  <entry>
    <title>mysql学习笔记</title>
    <url>/tantian123.github.io/2020/06/01/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.使用终端操作数据库<br>1.1登录<br>管理员模式下 打开命令提示符cmd<br>net stop mysql<br>net start mysql</p>
<p>1.2连接<br>mysql -u用户名 -p密码</p>
<p>1.3查询所有数据库<br>show databases;<br>1.4选中某一个数据库进行操作(不选不能操作)<br>use 数据库名<br>1.5选中后，查询某一个表<br>show tables;<br>select * from user</p>
<p>1.6退出<br>exit</p>
<p>2.使用可视化工具操作数据库</p>
<p>3.在java中使用数据库</p>
<hr>
<p>创建数据库<br>create database test;</p>
<p>建表<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>)<br>删除表<br>drop table user;</p>
<p>查看表的结果<br>describe user;简写为desc</p>
<p>增加数据记录<br>insert into user values(1,’tt’,’tt123456789’);</p>
<hr>
<p>mysql常用数据类型</p>
<p>三类 ：数值 日期  字符串<br>选择依据数据类型的大小</p>
<p>1.数值<br>常用的是<br>SMALLINT 2字节<br>INT  4字节<br>BIGINT 8字节<br>FLOAT  4字节<br>DOUBLE 8字节<br>2.日期<br>DATE   格式是’YYYY-MM-DD’<br>TIME 格式是’HH-MM-SS’<br>3.字符串<br>CHAR 0-255字节  定长字符串<br>VARCHAR 0-65535字节 变长字符串<br>TEXT 0-65535字节</p>
<hr>
<p>增删改查<br>1.insert<br>insert into user values(1,’tt’,’tt123456789’);<br>2.delete<br>delete from user where name=’tt’<br>3.update<br>update user set name=’tt’ where id=’1’<br>4.select<br>select * from user where name=’tt’</p>
<hr>
<p>约束<br>添加约束可以在建表的时候，也可以之后加</p>
<p>1.主键约束primary key<br>唯一确定一张表中的一条记录 该字段不重复且不为空(不能为NULL，不能与之前的重复)<br>create table user(<br>    id INT primary key,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>)<br>联合主键  加起来不重复就行<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20),<br>    primary key（id,name)<br>)</p>
<p>建表时忘记主键约束，之后修改<br>alter table user add primary key(id);<br>删除主键约束<br>alter table user drop primary key;<br>修改主键约束<br>alter table user modify id int primary key;</p>
<p>2.自增约束auto_increment  和主键约束一起用 自动管控id的值<br>create table user(<br>    id INT primary key auto_increment,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>) </p>
<p>3.外键约束<br>涉及到两个表 主表 副表<br>foreign key指明外键来自于哪个表<br>主表里面不存在的值，副表不能有<br>主表中被副表引用了的值，是不可以删除的</p>
<p>create table user(<br>    id INT primary key,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20)<br>)<br>create table company(<br>    id INT primary key,<br>    money INT,<br>    user_id INT,<br>    foreign key(user_id) references user(id)<br>)</p>
<p>4.唯一约束unique 不可重复<br>create table user(<br>    id INT,<br>    name VARCHAR(20)  unique,<br>    pwd VARCHAR(20)<br>)<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20),<br>    unique(name,id,pwd) //加在一起不重复就可以<br>)</p>
<p>alter table user add unique(name);</p>
<p>删除唯一约束<br>alter table user drop index name;//这里不是unique是因为唯一约束有多个<br>修改唯一约束<br>alter table user modify name varchar(20) unique;<br>5.非空约束 不为null<br>create table user(<br>    id INT,<br>    name VARCHAR(20)  not null,<br>    pwd VARCHAR(20)<br>)<br>6.默认约束 default<br>create table user(<br>    id INT,<br>    name VARCHAR(20),<br>    pwd VARCHAR(20) default ‘root’<br>)</p>
<hr>
<p>数据库的设计范式 NormalForm<br>1.第一范式 1NF<br><strong>各个属性不可再分</strong>（字段不可再分）<br>例如：表有地址这个属性，地址可以分为省、市、区、乡镇等，<br>所以整个地址设为一个字段，是不合理的。</p>
<p>2.第二范式 2NF<br>满足第一范式的基础上，要求非主属性对主属性是完全函数依赖，即<strong>不存在部分函数依赖</strong>（有主键，非主键列完全依赖于主键，不可以依赖主键的一部分）<br>例如：有这样一个表，它的字段有学生学号id，学生名字，课程编号id，课程名称<br>那么，课程名称是部分依赖主键（学生id,课程id）的，这样的表 不合理。<br>因为如果我没选课，这条数据就不能插入数据库。<br>所以需要划分为学生表和课程表。</p>
<p>3.第三范式 3NF<br>满足第二范式的基础上，要求<strong>不存在传递函数依赖</strong><br>例如：有这样一个表，学生学号id，学生证id，学生证说明。<br>那么，学生证说明是传递依赖于学生学号，不是直接依赖。<br>所以需要划分为学生表和学生证表。</p>
<p>4.BCNF<br>满足第三范式的基础上，不允许主键内部之间存在依赖<br>例如 主键为(学生，老师) 课程<br>这样的关系满足第三范式，但不满足BCNF范式</p>
<p>范式的优缺点:<br>减少冗余<br>结构清晰<br>性能降低</p>
<p>表之间关系的解释<br>一对一：学生和学生证   通过外键和唯一约束<br>一对多：学生和班级     通过外键<br>多对多：学生和老师     通过引入中间表</p>
<hr>
<p>与查询相关的知识<br>例子：<br>学生表 Student<br>学号 姓名 年龄 所在班级<br>课程表 Course<br>课程号，课程名称 教师编号<br>成绩表 Score<br>学号 课程号 成绩<br>老师表 Teacher<br>教师编号，教师名字，教师年龄</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    sname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    classid <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Teacher(</span><br><span class="line">    tid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    tname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(</span><br><span class="line">    cid <span class="built_in">varchar</span>(<span class="number">20</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    tid <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span>(tid) <span class="keyword">references</span> Teacher(tid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Score(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cid <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    score <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">sid</span>,cid),</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">sid</span>) <span class="keyword">references</span> Student(<span class="keyword">sid</span>),</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (cid) <span class="keyword">references</span> Course(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'谭天'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'罗杰'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'宋志豪'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'曾繁'</span>,<span class="string">'计科1703班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'xxx'</span>,<span class="string">'计科1000班'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'李老师'</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'刘老师'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'王老师'</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'孙老师'</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'1001'</span>,<span class="string">'语文课'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'1002'</span>,<span class="string">'数学课'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'1003'</span>,<span class="string">'英语课'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'2001'</span>,<span class="string">'理综课'</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1001'</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1002'</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1003'</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'2001'</span>,<span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'1002'</span>,<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">//问题</span><br><span class="line">1.查询学生的学号和名字</span><br><span class="line"></span><br><span class="line">2.查询学生的不重复的所在班级列 x 关键字</span><br><span class="line"></span><br><span class="line">3.查询成绩表 80-90分之间的记录</span><br><span class="line"></span><br><span class="line">4.查询成绩表 70 100或者90的记录</span><br><span class="line"></span><br><span class="line">5.查询老师 以年龄升序/降序</span><br><span class="line"></span><br><span class="line">6.查询计科1703班的人数</span><br><span class="line"></span><br><span class="line">7.查询最高分的学生的学号和对应的课程号（子查询或者排序后取第一个）x max函数</span><br><span class="line"></span><br><span class="line">8.查询学生1的平均分</span><br><span class="line"></span><br><span class="line">9.分别查询每名学生的平均分</span><br><span class="line"></span><br><span class="line">10.查询以'1'开头的课程的平均分 并且该课程至少有两人选择 </span><br><span class="line">having count关键字 xx</span><br><span class="line">先把至少两人选择的课程分组选出来 然后并上 like 1%</span><br><span class="line">最后在结果处计算平均分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,sname <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> classid <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="keyword">between</span> <span class="number">80</span> <span class="keyword">and</span> <span class="number">90</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> score &gt; <span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> score <span class="keyword">in</span>(<span class="number">70</span>,<span class="number">90</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;//asc可省略</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,cid <span class="keyword">from</span> score <span class="keyword">where</span> score=(<span class="keyword">select</span> <span class="keyword">max</span>(score) <span class="keyword">from</span> score);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,cid <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">sid</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>，<span class="keyword">avg</span>(score) <span class="keyword">from</span> score </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>;</span><br><span class="line"></span><br><span class="line">//分层次</span><br><span class="line"><span class="keyword">select</span> cid,<span class="keyword">avg</span>(score) <span class="keyword">from</span> score </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cid</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">sid</span>)&gt;=<span class="number">2</span> </span><br><span class="line"><span class="keyword">and</span> cid <span class="keyword">like</span> <span class="string">'1%'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//问题</span><br><span class="line">1.多表查询</span><br><span class="line">查询 所有学生的名字 课程号 分数 sname cid score(分别在student表和score表)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname,cid,score <span class="keyword">from</span> student,score</span><br><span class="line"><span class="keyword">where</span> student.sid=score.sid;</span><br><span class="line"></span><br><span class="line">查询 所有学生的名字 课程名 分数 所在列</span><br><span class="line"><span class="keyword">select</span> sname,cname,score,student.sid <span class="keyword">as</span> stu_id,course.cid <span class="keyword">as</span> cou_id <span class="keyword">from</span> student,score,course</span><br><span class="line"><span class="keyword">where</span> student.sid=score.sid <span class="keyword">and</span> score.cid=course.cid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.子查询</span><br><span class="line">查询计科1703班学生每门课的平均分</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;)</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">select</span> cid,<span class="keyword">avg</span>(score) <span class="keyword">from</span> score <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> student <span class="keyword">where</span> classid=<span class="string">'计科1703班'</span>;) </span><br><span class="line">group by cid;</span><br></pre></td></tr></table></figure>




<hr>
<p>mysql的四种连接查询</p>
<p>内连接 把有关系的数据查询出来<br>inner join 或者join<br>外连接<br>1.左连接<br>left join 或者 left outer join<br>2.右连接<br>right join 或者 right outer join<br>3.完全外连接<br>full join  或者 full outer join</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">person表和card表</span><br><span class="line">person  id name cardID</span><br><span class="line">card    id name</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>;</span><br><span class="line">    name varchar(20);</span><br><span class="line">    cardID int</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> card(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>;</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> card <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'饭卡'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> card <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'银行卡'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'张三'</span>，<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'李四'</span>，<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'王五'</span>，<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">1.内连接 把有关系的数据查询出来</span><br><span class="line">这里故意没有外键</span><br><span class="line">那么 我们要使用 inner join查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">inner</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id;</span><br><span class="line"></span><br><span class="line">// on 表示连接条件</span><br><span class="line"></span><br><span class="line">2. left join  左边表内容全查出来；右边表有的显示，没有的补null</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id;</span><br><span class="line"></span><br><span class="line">3. right join  右边表内容全查出来；左边表有的显示，没有的补null</span><br><span class="line"></span><br><span class="line">4.mysql没有外连接</span><br><span class="line">使用union</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">inner</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> card <span class="keyword">on</span> person.cardID=card.id;</span><br></pre></td></tr></table></figure>






<hr>
<p>mysql事务</p>
<p>自动commit的开启和关闭</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//禁止默认的自动提交 <span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span> </span><br><span class="line">//开启自动提交 <span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'神秘人'</span>,<span class="string">'异次元'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>

<p>手动commit<br>begin;或者 start transaction;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'神秘人'</span>,<span class="string">'异次元'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>


<p>事务的隔离级别<br>1.read uncommitted;  读未提交<br>2.read committed;    读已提交<br>3.repeatable read;   可重复读<br>4.serializable;    可串行化</p>
<p>MySQL 数据库默认的事务隔离级别是 REPEATABLE_READ (可重复读)。</p>
<p>修改隔离级别<br>设置全局的事务隔离级别<br>set global transaction isolation level read committed;<br>设置本次会话的事务隔离级别<br>set session transaction isolation level read committed;</p>
]]></content>
  </entry>
  <entry>
    <title>mybatis学习</title>
    <url>/tantian123.github.io/2020/05/29/mybatis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>复制自 <a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<blockquote>
<p>持久层框架   完成持久化的代码块（内存-文件）<br>免除了几乎所有的 JDBC 代码<br>通过XML和注解<br>ORM 对象关系映射 将java面向对象的实体类 转换为 MYSQL的面向关系的表</p>
</blockquote>
<h1 id="为什么需要MyBatis？"><a href="#为什么需要MyBatis？" class="headerlink" title="为什么需要MyBatis？"></a>为什么需要MyBatis？</h1><p>传统的JDBC代码太复杂了，所以有了框架</p>
<p>映射 将对象映射标签<br>灵活，不对现有代码强加影响<br>解耦合，sql和代码分离<br>提供xml标签，支持动态sql</p>
<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>新建maven工程<br>pom.xml 导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-建表User"><a href="#2-建表User" class="headerlink" title="2.建表User"></a>2.建表User</h1><p>在数据库中新建user表</p>
<h1 id="3-建立表对应的实体类User（pojo）"><a href="#3-建立表对应的实体类User（pojo）" class="headerlink" title="3.建立表对应的实体类User（pojo）"></a>3.建立表对应的实体类User（pojo）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-创建Mybatis配置文件"><a href="#4-创建Mybatis配置文件" class="headerlink" title="4.创建Mybatis配置文件"></a>4.创建Mybatis配置文件</h1><p>在resource下，新建mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Mybatis运行环境 可以有多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置JDBC事务管理--&gt;</span><span class="comment">&lt;!----&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--dataSource是数据源  POOLED配置JDBC数据源连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--driver驱动  url哪个数据库 username用户名password密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"tt123456789"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册该usermapper.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由上面可见，配置文件的作用就是连接到数据库和注册mapper</p>
<h1 id="5-1使用原生接口-不推荐"><a href="#5-1使用原生接口-不推荐" class="headerlink" title="5.1使用原生接口  不推荐"></a>5.1使用原生接口  不推荐</h1><h3 id="1-mybatis框架需要开发者自定义sql语句，写在mapper-xml里面"><a href="#1-mybatis框架需要开发者自定义sql语句，写在mapper-xml里面" class="headerlink" title="1.mybatis框架需要开发者自定义sql语句，写在mapper.xml里面"></a>1.mybatis框架需要开发者自定义sql语句，写在mapper.xml里面</h3><p>实际开发中，会为每个实体类创建mapper.xml来定义管理该对象数据的sql</p>
<p>user.java  -&gt;  usermapper.xml</p>
<p>usermapper.xml如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapper 里面就是各种语句 insert标签就是insert语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace是带着包名的全路径 无后缀--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id是调用这句sql语句 调用的方法名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  parameterType就是调用这个方法传入的参数类型 例如User--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#&#123;userid&#125;意思就是 取得 User对象里面的userid字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        insert into User(id,name,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在全局配置文件中注册该usermapper-xml"><a href="#2-在全局配置文件中注册该usermapper-xml" class="headerlink" title="2.在全局配置文件中注册该usermapper.xml"></a>2.在全局配置文件中注册该usermapper.xml</h3><p>在后面加一个标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-调用mybatis原生接口实现操作"><a href="#3-调用mybatis原生接口实现操作" class="headerlink" title="3.调用mybatis原生接口实现操作"></a>3.调用mybatis原生接口实现操作</h3><p>在test测试类main函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 XML 中构建 SqlSessionFactory</span></span><br><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactoryBuilder sqlSessionFactoryBuilder=<span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line"><span class="comment">//从 SqlSessionFactory 中获取 SqlSession</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//调用方法 根据namespace.id调用</span></span><br><span class="line">String statement=<span class="string">"dao.UserMapper.insert"</span>;</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">"khan"</span>,<span class="number">26</span>);</span><br><span class="line">sqlSession.insert(statement,user);</span><br><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure>


<p>这里还有一个大坑！<br>java文件夹下的xml不会编译（和resource文件夹下不同）所以在Mybatis的配置文件中找不到xml文件</p>
<p>所以需要修改pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/mybatis1.jpg" alt="第一种方式的项目结构"></p>
<h1 id="5-2使用mapper代理"><a href="#5-2使用mapper代理" class="headerlink" title="5.2使用mapper代理"></a>5.2使用mapper代理</h1><p>使用mapper代理自定义接口 （推荐第二种方法）</p>
<ul>
<li>1.自定义接口，定义方法 （mapper会自动生成接口的实现类）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//自定义接口 不需要写它的实现类 写对应的mapper</span><br><span class="line">public interface UserRepository &#123;</span><br><span class="line">    public int save(User user);</span><br><span class="line">    public int update(User user);</span><br><span class="line">    public void delete(int id);</span><br><span class="line">    public List&lt;User&gt; findall();</span><br><span class="line">    public User select(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2.编写与方法对应的UserRepository.xml文件 定义sql方法对应的接口的方法<br>UserRepository.xml 中namespace为接口的全类名  id为接口中对应的方法名<br>UserRepository.xml   元素和UserRepository.java一一对应<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapper 里面就是各种语句 insert标签就是insert语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace是接口的全路径 无后缀--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id是调用这句sql语句 调用的方法名  sqlsession调用的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  parameterType就是调用这个方法传入的参数类型 例如User--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#&#123;userid&#125;意思就是 取得 User对象里面的userid字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"repository.UserRepository"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        insert into User(id,name,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        update User set id=#&#123;id&#125;,name=#&#123;name&#125;,age=#&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from User where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findall"</span> <span class="attr">resultType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"select"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">        select * from User where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>3.这个mapper也要注册<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"repository/UserRepository.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>4.使用<br>新建test2.java  在得到sqlsession之前的步骤是一样的<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 XML 中构建 SqlSessionFactory</span></span><br><span class="line">       String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">       InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">       SqlSessionFactoryBuilder sqlSessionFactoryBuilder=<span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">       SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">       <span class="comment">//从 SqlSessionFactory 中获取 SqlSession</span></span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       <span class="comment">//获取实现了接口的代理对象</span></span><br><span class="line">       UserRepository userRepository=sqlSession.getMapper(UserRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       List&lt;User&gt; list=userRepository.findall();</span><br><span class="line">       <span class="keyword">for</span>(User u:list)</span><br><span class="line">           System.out.println(u);</span><br></pre></td></tr></table></figure>






</li>
</ul>
<h1 id="执行一条SQL的过程总结"><a href="#执行一条SQL的过程总结" class="headerlink" title="执行一条SQL的过程总结"></a>执行一条SQL的过程总结</h1><p>实体类 mapper接口 mapper配置文件<br>1.通过 SqlSessionFactoryBuilder 构造 SqlSessionFactory 对象<br>2.SqlSessionFactory 通过 openSession() 方法获取 SqlSession 对象<br>3.通过 SqlSession 获得 mapper 代理对象<br>4.通过 mapper 代理对象执行数据库操作<br>5.执行成功，使用 SqlSession 提交事务，执行失败，使用 SqlSession 回滚事务</p>
<h1 id="解决属性名和字段名不一致的问题"><a href="#解决属性名和字段名不一致的问题" class="headerlink" title="解决属性名和字段名不一致的问题"></a>解决属性名和字段名不一致的问题</h1><p>问题：<br>如果User的属性名是password 数据库里面的字段名是pwd<br>查询出来的password会为null<br>原因：<br>通过类型处理器，它找不到pwd<br>如何解决：<br>1.起别名 select password as pwd from user;<br>2.resultMap 结果集映射<br>用来处理不能直接映射的情况</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findall"</span> <span class="attr">resultType</span>=<span class="string">"pojo.User"</span>&gt;</span></span><br><span class="line">改为</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findall"</span> <span class="attr">resultMap</span>=<span class="string">"UserMap"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果集映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--result 代表结果 colunm是列（数据库的字段）  property是属性（类的属性）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colunm</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colunm</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colunm</span>=<span class="string">"pwd"</span> <span class="attr">property</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>resultMap的设计思想，对于简单的语句不需要显示的结果映射，对于复杂的语句只需要描述它们的关系</strong></p>
<h1 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h1><p>两种实现方式：业务扩展类和resultmap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">两个表 学生表和学生证表</span><br><span class="line"></span><br><span class="line">学生表 字段为学号 学生姓名 学生证号</span><br><span class="line">学生证表 字段为 学生证号 学生证介绍</span><br><span class="line">class student&#123;</span><br><span class="line">    int sid;</span><br><span class="line">    String sname;</span><br><span class="line">    int cardid;</span><br><span class="line">&#125;</span><br><span class="line">class card&#123;</span><br><span class="line">    int cardid;</span><br><span class="line">    String cardmsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：如果我们要查询某个学生id 对应的全部信息</span><br><span class="line">1.扩展类方法 studentAndcard类 让业务扩展类包含所有要查的字段  resultType</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryStudentAndCardById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"pojo.studentAndcard"</span>&gt;</span></span><br><span class="line">select * from student scard where student.cardid=scard.cardid and s.id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UserRepository userRepository=sqlSession.getMapper(UserRepository.class);</span><br><span class="line">studentAndcard sc=userRepository.queryStudentAndCardById(id);</span><br><span class="line">System.out.println(sc);</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">2.resultmap方法</span><br><span class="line">用两个类分别接收</span><br><span class="line">如何建立二者之间的关系？</span><br><span class="line">把一个类作为另一个类的成员,从而建立联系</span><br><span class="line">class student&#123;</span><br><span class="line">    int sid;</span><br><span class="line">    String sname;</span><br><span class="line">    int cardid;</span><br><span class="line">    Card card;</span><br><span class="line">&#125;</span><br><span class="line">class card&#123;</span><br><span class="line">    int cardid;</span><br><span class="line">    String cardmsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不再使用resultType 使用resultMap</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryStudentAndCardById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"studentAndcard"</span>&gt;</span></span><br><span class="line">select * from student scard where student.cardid=scard.cardid and s.id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">//resultMap的type就是整个select语句的返回值  id就是resultMap的名字</span><br><span class="line">//这里使用student是因为它已经扩展了，他此时包含了card类</span><br><span class="line">//<span class="tag">&lt;<span class="name">id</span>&gt;</span>是主键 <span class="tag">&lt;<span class="name">result</span>&gt;</span>是搜索结果</span><br><span class="line">//对象成员  **一对一使用association   一对多使用collection**</span><br><span class="line">//javaType指定该属性的类型</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"student"</span> <span class="attr">id</span>=<span class="string">"studentAndcard"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"sid"</span> <span class="attr">column</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sname"</span> <span class="attr">column</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"cardid"</span> <span class="attr">column</span>=<span class="string">"cardid"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"card"</span> <span class="attr">javaType</span>=<span class="string">"pojo.card"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cardid"</span> <span class="attr">property</span>=<span class="string">"cardid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cardmsg"</span> <span class="attr">property</span>=<span class="string">"cardmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">接口</span><br><span class="line">Student queryStudentAndCardById(int id);</span><br><span class="line">测试</span><br><span class="line">StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student s=StudentMapper.queryStudentAndCardById(1);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>



<h1 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h1><p>只有一种方式，在班级类里增加学生属性<br>因为是一对多，所以是list<student></p>
<p>班级类和学生类<br>班级类<br>classid classname<br>学生类<br>sid sname classid</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">class student&#123;</span><br><span class="line">    int sid;</span><br><span class="line">    String sname;</span><br><span class="line">    int classid;</span><br><span class="line">&#125;</span><br><span class="line">class classes&#123;</span><br><span class="line">    int classid;</span><br><span class="line">    String classname;</span><br><span class="line"></span><br><span class="line">    List<span class="tag">&lt;<span class="name">Student</span>&gt;</span> students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"querytogetstudents"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"classes_students"</span>&gt;</span></span><br><span class="line">select * from classes,student where classes.classid=student.classid and classid=#&#123;classid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"classes"</span> <span class="attr">id</span>=<span class="string">"classes_students"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"classid"</span> <span class="attr">column</span>=<span class="string">"classid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"classname"</span> <span class="attr">column</span>=<span class="string">"classname"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//描述该属性的类型是javaType  描述该属性 里面的元素的类型 是ofType</span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"pojo.student"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"sid"</span> <span class="attr">property</span>=<span class="string">"sid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sname"</span> <span class="attr">property</span>=<span class="string">"sname"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>






<h1 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h1><p>resultMap 一对一问题/类型不一致问题</p>
<p>一对多==多对一<br>要先了解数据库里 什么是一对多/多对一<br>学生 学号 老师 班级<br>学生和学号是一对一<br>学生和班级是多对一<br>学生和老师是多对多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int id;</span><br><span class="line">    int tid;</span><br><span class="line">    Teacher teacher;//学生里面有一个老师</span><br><span class="line">&#125;</span><br><span class="line">class Teacher&#123;</span><br><span class="line">    int tid;</span><br><span class="line">    String tname;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我要查询学生以及对应的老师<br>select s.id,s.name,t.name from student s,teacher t where t.tid=s.id;</p>
<p>student的teacher属性查出的结果会是null</p>
<h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><p>目的：我要查询所有student<br>问题：student对象中有teacher属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from teacher where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单个的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--复杂的属性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对象用association--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置封装Teacher  column是 用哪个字段来获取对象   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"tid"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tname"</span> <span class="attr">property</span>=<span class="string">"tname"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from teacher where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查出来的是一个叫StudentTeacher的东西，其中的单个属性类型用result  其中的对象类型用association（association的作用就是组成一个对象类型）</p>
<h1 id="日志的使用"><a href="#日志的使用" class="headerlink" title="日志的使用"></a>日志的使用</h1><p>使用mapper映射 我们如何输出sql日志？<br>日志的作用是排错。<br>排错之前使用的是sout,debug<br>现在我们使用日志工厂</p>
<p>两种日志:</p>
<ul>
<li>LOG4J</li>
<li>STDOUT_LOGGING 标准日志输出</li>
</ul>
<h2 id="1-标准日志输出"><a href="#1-标准日志输出" class="headerlink" title="1.标准日志输出"></a>1.标准日志输出</h2><p>mybatis_congfig.xml添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-LOG4J日志"><a href="#2-LOG4J日志" class="headerlink" title="2.LOG4J日志"></a>2.LOG4J日志</h2><p>使用LOG4J需要导包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在resource下新建log4j.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># priority  :debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">#you cannot specify every priority with different file for log4j</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug,stdout,info,debug,warn,error </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#console</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender </span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>= <span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n</span></span><br><span class="line"><span class="comment">#info log</span></span><br><span class="line"><span class="meta">log4j.logger.info</span>=<span class="string">info</span></span><br><span class="line"><span class="meta">log4j.appender.info</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.info.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.info.File</span>=<span class="string">./log/info.log</span></span><br><span class="line"><span class="meta">log4j.appender.info.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.info.Threshold</span>=<span class="string">INFO</span></span><br><span class="line"><span class="meta">log4j.appender.info.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.info.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br><span class="line"><span class="comment">#debug log</span></span><br><span class="line"><span class="meta">log4j.logger.debug</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">log4j.appender.debug</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.debug.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.debug.File</span>=<span class="string">./src/com/hp/log/debug.log</span></span><br><span class="line"><span class="meta">log4j.appender.debug.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.debug.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.debug.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.debug.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br><span class="line"><span class="comment">#warn log</span></span><br><span class="line"><span class="meta">log4j.logger.warn</span>=<span class="string">warn</span></span><br><span class="line"><span class="meta">log4j.appender.warn</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.warn.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.warn.File</span>=<span class="string">./src/com/hp/log/warn.log</span></span><br><span class="line"><span class="meta">log4j.appender.warn.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.warn.Threshold</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">log4j.appender.warn.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="meta">log4j.appender.warn.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br><span class="line"><span class="comment">#error</span></span><br><span class="line"><span class="meta">log4j.logger.error</span>=<span class="string">error</span></span><br><span class="line"><span class="meta">log4j.appender.error</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.error.DatePattern</span>=<span class="string">'_'yyyy-MM-dd'.log'</span></span><br><span class="line"><span class="meta">log4j.appender.error.File</span> = <span class="string">./src/com/hp/log/error.log </span></span><br><span class="line"><span class="meta">log4j.appender.error.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.error.Threshold</span> = <span class="string">ERROR </span></span><br><span class="line"><span class="meta">log4j.appender.error.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.error.layout.ConversionPattern</span> = <span class="string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span></span><br></pre></td></tr></table></figure>

<p>mybatis_congfig.xml添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>log4j的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">Logger logger=Logger.getLogger(Test4<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">logger.info(<span class="string">"测试info"</span>);</span><br><span class="line">logger.debug(<span class="string">"测试debug"</span>);</span><br><span class="line">logger.error(<span class="string">"测试error"</span>);</span><br></pre></td></tr></table></figure>



<h1 id="实现分页"><a href="#实现分页" class="headerlink" title="实现分页"></a>实现分页</h1><p>为什么要分页<br>减少每次处理的数据</p>
<p>实现方式<br>1.limit</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> startIndex,pageSize;</span><br></pre></td></tr></table></figure>
<p>pageSize=-1 是直到最后一个元素（现在不可用）</p>
<p>2.mybatis实现</p>
<h1 id="mybatis缓存"><a href="#mybatis缓存" class="headerlink" title="mybatis缓存"></a>mybatis缓存</h1><p>一级缓存   sqlsession级别 默认开启</p>
<p>如果执行了insert/update/delete的sql语句，缓存必须清空</p>
<p>二级缓存 mapper级别  默认关闭<br>打开时，多个sqlsession使用同一个mapper的sql语句执行<br>得到的数据存在二级缓存区（使用hashmap进行存储）<br>跨sqlsession的，作用域是mapper的同一个namespace</p>
<p>1.修改mybatis_config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnable"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.在mapper.xml中配置二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.对应的实体类实现序列化接口</p>
<h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><h2 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h2><p>程序根据业务参数来决定SQL的组成</p>
<h2 id="在什么情况下："><a href="#在什么情况下：" class="headerlink" title="在什么情况下："></a>在什么情况下：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id=""&gt;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="comment">#&#123;&#125; and userid=#&#123;&#125; and password=#&#123;&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们输入的 userid为空，我们希望这个语句也能查出结果<br>所有需要添加if-else条件判断语句</p>
<h2 id="怎么做："><a href="#怎么做：" class="headerlink" title="怎么做："></a>怎么做：</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">select * from user where </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span>username=#&#123;username&#125; and<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userid!=0"</span>&gt;</span>userid=#&#123;userid&#125; and<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password!=null"</span>&gt;</span>password=#&#123;password&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这么做的缺点   and不好处理<br>2.需要<where>标签  where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">select * from user where </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span>username=#&#123;username&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userid!=0"</span>&gt;</span>and userid=#&#123;userid&#125; and<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password!=null"</span>&gt;</span>and password=#&#123;password&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3.choose和when标签<br>相当于switch case break（满足第一个when后，后面的语句不会执行）</p>
<p>4.trim标签<br>prefix和suffix属性 会用于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>set标签  用于update操作<br>取消不用修改的多余字段的update</p>
<p>5.foreach标签<br>用于in语句<br>select * from user where userid in (1,2,3)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIds"</span>&gt;</span></span><br><span class="line">    select * from user </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"id in ("</span>  <span class="attr">close</span>=<span class="string">")"</span>  <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h1 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h1><p>mybatis-spring包</p>
]]></content>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/tantian123.github.io/2020/05/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h1><p>为什么需要代理类？<br>对既有代码不改动的情况下进行功能的扩展<br>例如：Aop </p>
<p>代理模式的实现方式：动态代理，静态代理</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>例子<br>    实现Runnble接口<br>缺点<br>    1.代理类和被代理类都是在编译期间被确定了，不利于扩展<br>    2.每个代理类只能为一个/一套接口服务，那么整个程序会有很多代理类，冗余</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要求：1.代理类和被代理实现同一个接口</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">动态代理</span><br><span class="line">是反射的应用</span><br><span class="line"></span><br><span class="line">动态代理的应用：调试，远程方法调用</span><br><span class="line">优缺点：</span><br><span class="line">优点：解决静态代理的缺点， 在程序运行时动态创建被代理类的代理对象</span><br><span class="line"></span><br><span class="line">动态代理的实现  两种方式 jdk动态代理/cglib</span><br><span class="line">jdk动态代理只能对接口做代理  /cglib是框架 通过asm字节码技术</span><br><span class="line">jdk动态代理 两个步骤： </span><br><span class="line"><span class="number">1</span>.根据加载到内存的被代理类，动态创建代理类对象  使用java.lang.reflect.Proxy类，通过Proxy.newProxyInstance()方法实现</span><br><span class="line"></span><br><span class="line">创建了一个动态代理对象</span><br><span class="line"><span class="number">2</span>.代理类对象 调用方法a时，如何能去调用被代理类的a方法,InvocationHandler接口及其invoke方法</span><br><span class="line"></span><br><span class="line">使用InvocationHandler调用方法</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Object类常用方法</title>
    <url>/tantian123.github.io/2020/05/27/Object%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h1><p>获得运行时类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h1><p>Returns a hash code value for the object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>
<p>两个对象相同，它们的hashcode值一定要相同<br>两个对象不同，它们的hashcode值可能相同也可能不同<br>重写equals()就一定要重写hashCode()</p>
<h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span> == obj;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>只不过，String类重写了equals方法</p>
<h1 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h1><p>实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法<br>具体的实现是有C/C++完成的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h1><p>注意 char数组没有toString()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我门system.out.print(obj)时，其实调用了tostring</p>
<h1 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h1><p>该方法唤醒在该对象上等待的某个线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void notify();</span><br></pre></td></tr></table></figure>
<h1 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h1><p>该方法唤醒在该对象上等待的所有线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void notifyAll();</span><br></pre></td></tr></table></figure>
<h1 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>
<h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h1><h1 id="重写equals-方法就必须重写hashCode-方法"><a href="#重写equals-方法就必须重写hashCode-方法" class="headerlink" title="重写equals()方法就必须重写hashCode()方法"></a>重写equals()方法就必须重写hashCode()方法</h1><p>针对HashSet和Map集合类型<br>如果只重写了equals()方法，没有重写hashCode()<br>那么两个相同属性的对象，因为hashcode不同，所以能同时存在于集合中。</p>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/tantian123.github.io/2020/05/26/java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>反射的概念<br>小写是关键字 大写是类</li>
</ul>
<p>class类的常用方法<br>classforname<br>newinstance<br>getclassloader<br>getconstruction<br>getmethod<br>getDeclaredFields</p>
<ul>
<li>原理<br>  优缺点  灵活 性能低了</li>
<li>应用<br>  反射相关的类<br>  框架</li>
</ul>
<h1 id="获取class类"><a href="#获取class类" class="headerlink" title="获取class类"></a>获取class类</h1><p>1.调用类的.class属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1=String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
<p>2.通过对象获取  getClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">Class c1=p.getClass();</span><br></pre></td></tr></table></figure>
<p>3.通过Class的静态方法 forName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1=Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p>4.通过类的加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader cl=<span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class c1=cl.loadClass(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p>2.通过基本数据类型的TYPE属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span></span>=Integer.TYPE;</span><br></pre></td></tr></table></figure>
<p>获取父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c2=c1.getSuperClass();</span><br></pre></td></tr></table></figure>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>1.将class字节码文件读入内存，<br>2.将这些静态数据转换为方法区的运行时数据结构<br>3.生成唯一的一个代表这个类的java.lang.Class对象，接下来所有对该类的访问都通过这个对象<br>以上通过类的加载器实现</p>
<h2 id="类的链接（验证-准备-解析）"><a href="#类的链接（验证-准备-解析）" class="headerlink" title="类的链接（验证 准备 解析）"></a>类的链接（验证 准备 解析）</h2><p>1.验证 保证二进制字节流中的信息符合虚拟机规范，并没有安全问题（例如java数组不能越界访问）<br>2.准备  (1)为已经在方法区中的类中的静态成员变量分配内存 (2)为静态成员变量设置初始值 例如0<br>3.解析<br>虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用</p>
<blockquote>
<p>符号引用：hello<br>直接引用：0xaabbccdd</p>
</blockquote>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>1.就是执行类构造器cinit()的过程<br>cinit()是由静态代码块和类变量的赋值语句 合并组成的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class people&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        m=300;</span><br><span class="line">    &#125;</span><br><span class="line">    static int m=100;</span><br><span class="line">&#125;</span><br><span class="line">合并后</span><br><span class="line">cinit()&#123;</span><br><span class="line">     m=300;</span><br><span class="line">     m=100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类构造器是构造类的信息的 cinit=class init</p>
</blockquote>
<p>2.当初始化一个类时，先检查父类是否初始化，否则先初始化父类<br>3.虚拟机会保证一个类的cinit()方法在多线程中被正确加锁和同步</p>
<h2 id="什么时候进行类初始化"><a href="#什么时候进行类初始化" class="headerlink" title="什么时候进行类初始化"></a>什么时候进行类初始化</h2><p>类的主动引用，类初始化<br>类的被动引用，不会类初始化</p>
<p>主动引用</p>
<ul>
<li>虚拟机启动，初始化main</li>
<li>new一个类的对象</li>
<li>调用类的静态方法和静态成员</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>初始化一个类，如果它的父类没有初始化，就会先初始化父类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//输出main</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.主动引用</span></span><br><span class="line">        <span class="comment">//new</span></span><br><span class="line">        Son s=<span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//反射</span></span><br><span class="line">        Class.forName(<span class="string">"com.tt.test.son"</span>);</span><br><span class="line">        <span class="comment">//2.被动引用</span></span><br><span class="line">        System.out.println(Son.a);<span class="comment">//子类不被加载，虽然是通过子类调用的</span></span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        Son[] sonArray=<span class="keyword">new</span> Son[<span class="number">5</span>];<span class="comment">//只有main类被加载。数组只占空间</span></span><br><span class="line">        <span class="comment">//引用常量</span></span><br><span class="line">        System.out.println(Son.N);<span class="comment">//只有main类被加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//输出father</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//输出son</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>被动引用</p>
<ul>
<li>访问静态域，只有真正声明这个域的类会被初始化，其它类引用的不算（通过子类引用父类的静态变量，不会导致子类初始化，其实根本不关子类的事）</li>
<li>数组定义类引用，不会触发此类初始化（数组只占空间）</li>
<li>引用常量（常量在常量池里,链接阶段就存入了）</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>作用：</p>
<p>类缓存：一旦类被加载到类加载器中，会被维持一段时间，GC回收这些class对象</p>
<p>类加载器：<br>1.引导类加载器 Bootstap ClassLoader<br>c++编写,负责加载核心库<br>2.扩展类加载器 Extension ClassLoader<br>负责jre/lib/ext下的jar包<br>3.系统类加载器 System ClassLoader<br>负责classpath下的类与jar包</p>
<h3 id="如何获取类加载器"><a href="#如何获取类加载器" class="headerlink" title="如何获取类加载器"></a>如何获取类加载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统类加载器</span></span><br><span class="line">ClassLoader systemcl=ClassLoader.getSystemClassLoader；</span><br><span class="line">System.out.println(systemcl.getParent());</span><br><span class="line">System.out.println(systemcl.getParent().getParent());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前类的加载器</span></span><br><span class="line">ClassLoader cl=Class.forName(<span class="string">"java.lang.object"</span>).getClassLoader;</span><br></pre></td></tr></table></figure>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>导致 自己写的java.lang.String无效 的原因</p>
<h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><p>Field Method  Constructor Interface Annotation Superclass<br>java.lang.class<br>java.lang.reflect.Method/Field/Constructor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"xx"</span>);</span><br><span class="line"><span class="comment">//获得类名</span></span><br><span class="line">c.getName();<span class="comment">//获得类名</span></span><br><span class="line"></span><br><span class="line">c.getSimpleName();<span class="comment">//获得包名+类名</span></span><br><span class="line"><span class="comment">//获得类的属性</span></span><br><span class="line">Field[] fields=c.getFields();<span class="comment">//打印public属性</span></span><br><span class="line">Field[] fields=c.getDeclaredFields();<span class="comment">//打印所有属性</span></span><br><span class="line">Field field=c.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//指定属性的值</span></span><br><span class="line"><span class="comment">//获得类的方法</span></span><br><span class="line">c.getMethods();<span class="comment">//获得本类和父类的所有public方法</span></span><br><span class="line">c.getDeclaredMethods();<span class="comment">//获得本类的所有方法（没有父类）</span></span><br><span class="line"></span><br><span class="line">c.getMethod(name,<span class="keyword">null</span>);<span class="comment">//指定方法   null参数指明要不要返回参数（以区别重载）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造器</span></span><br><span class="line">Constructor[] constructors=c.getConstructors();</span><br><span class="line"></span><br><span class="line">c.getDeclaredConstructors(参数<span class="number">1</span><span class="class">.<span class="keyword">class</span>,参数2.<span class="title">class</span> ...)//获得指定的构造器</span></span><br></pre></td></tr></table></figure>

<h2 id="获得class对象之后-创建类的对象-方法-属性"><a href="#获得class对象之后-创建类的对象-方法-属性" class="headerlink" title="获得class对象之后,创建类的对象/方法/属性"></a>获得class对象之后,创建类的对象/方法/属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"xxx.User"</span>);</span><br><span class="line"><span class="comment">//通过反射构造了无参对象</span></span><br><span class="line">User user=(User)c.newInstance();</span><br><span class="line"><span class="comment">//通过构造器创建有参对象</span></span><br><span class="line">Constructor constructor=c.getConstructor(参数<span class="number">1</span><span class="class">.<span class="keyword">class</span>,参数2.<span class="title">class</span> ...)</span>;</span><br><span class="line">User user2=(User)constructor.newInstance(<span class="string">"参数1的值"</span>,<span class="string">"参数2的值"</span>,<span class="string">"参数3的值"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射调用方法</span></span><br><span class="line">User user=(User)c.newInstance();</span><br><span class="line">Method method=c.getDeclaredMethod(<span class="string">"setName"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(user,<span class="string">"tantian"</span>);<span class="comment">//invoke (意思是调用/激活) 参数是：（对象，“方法的值”）</span></span><br><span class="line">System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射操作属性</span></span><br><span class="line">User user=(User)c.newInstance();</span><br><span class="line">Field f=c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f.set(user,<span class="string">"tantian"</span>);</span><br><span class="line"></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);<span class="comment">//关掉private权限检查</span></span><br><span class="line">System.out.println(user.getName());</span><br></pre></td></tr></table></figure>



<h2 id="通过反射获取泛型信息"><a href="#通过反射获取泛型信息" class="headerlink" title="通过反射获取泛型信息"></a>通过反射获取泛型信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Map&lt;Integer,String&gt;)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Method method=Person.class.getMethod("test1",Map.class);</span><br><span class="line">        <span class="comment">//参数类型</span></span><br><span class="line">        Type[] gpt=method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type t:gpt)&#123;</span><br><span class="line">            <span class="comment">//输出了Map&lt;Integer,String&gt;</span></span><br><span class="line">            <span class="comment">//if(是集合) 返回真实类型 代码省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值类型</span></span><br><span class="line">        getGenericReturnTypes()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获取注解信息"><a href="#通过反射获取注解信息" class="headerlink" title="通过反射获取注解信息"></a>通过反射获取注解信息</h2><p>getAnnotations/getAnnotation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">理解动态语言和静态语言</span><br><span class="line">动态语言：运行时改变结构</span><br><span class="line">js，php，python</span><br><span class="line">静态语言</span><br><span class="line">java c c++</span><br><span class="line">java有一定的动态性，利用反射机制获得动态语言的特性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行时注入的概念，例如游戏外挂在程序运行时修改数据</span><br><span class="line">应用：获取注解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反射机制运行程序在执行期间借助Reflection API获取任何类的内部信息（构造器，字段等）</span><br><span class="line">并直接操作任意对象的属性和方法</span><br><span class="line"></span><br><span class="line">Class c=Class.forName(<span class="string">"java.lang.String"</span>)</span><br><span class="line"></span><br><span class="line">在堆的方法区产生了<span class="class"><span class="keyword">class</span>类型对象 ，包含了类的完整的结构信息</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">通过反射创建对象-&gt;<span class="title">getclass</span>-&gt; 获得类的完整包名</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">功能：运行时判断对象所属的类/成员变量/方法</span></span><br><span class="line"><span class="class">运行时构造类的对象</span></span><br><span class="line"><span class="class">生成动态代理</span></span><br><span class="line"><span class="class">运行时处理注解</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Class</span>有一个静态方法<span class="title">forname</span> 获得<span class="title">Class</span>对象</span></span><br><span class="line"><span class="class">使用方式</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">c</span></span>=Class.forName(<span class="string">"包里的类路径"</span>)</span><br><span class="line"></span><br><span class="line">一个<span class="class"><span class="keyword">class</span>只有一个对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">获取<span class="title">class</span>类的实例的方式</span></span><br><span class="line"><span class="class"><span class="title">person</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">getClass</span></span></span><br><span class="line"><span class="class"><span class="title">Class</span>.<span class="title">forName</span></span></span><br><span class="line"><span class="class"><span class="title">classloader</span></span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java注解</title>
    <url>/tantian123.github.io/2020/05/26/java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>注解的基本概念<ul>
<li>注解的格式</li>
<li>注解类型<ul>
<li>元注解 注解其他注解</li>
<li>内置注解</li>
<li>自定义注解</li>
</ul>
</li>
</ul>
</li>
<li>注解的原理</li>
<li>注解的解析</li>
<li>注解的应用场景<ul>
<li>编译检查</li>
<li>在反射中使用 </li>
</ul>
</li>
</ul>
<h1 id="1-注解的基本概念"><a href="#1-注解的基本概念" class="headerlink" title="1.注解的基本概念"></a>1.注解的基本概念</h1><p>Annotation注解<br>可以把注解理解为代码里的特殊标记，这些标记可以<strong>在编译，类加载，运行时</strong>被读取，并执行相应的处理。通过注解开发人员可以在<strong>不改变原有代码和逻辑</strong>的情况下在源代码中嵌入补充信息。<br>说人话就是，不是程序本身，对程序起解释作用，可以被编译器读取。</p>
<h2 id="1-1注解的格式"><a href="#1-1注解的格式" class="headerlink" title="1.1注解的格式"></a>1.1注解的格式</h2><p>在需要注解的地方的上一行 加上 @注解名 就可以了<br><strong>可以用在于类，构造函数和字段的声明处</strong><br>即package，class，method，field上面</p>
<h2 id="1-2注解类型"><a href="#1-2注解类型" class="headerlink" title="1.2注解类型"></a>1.2注解类型</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>基本注解，能注解其它注解,在java.lang.annotation下<br>有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。<br>@Retention 描述注解存在的阶段（编译期/类加载时/运行时）<br>@Documented 能够将注解中的元素包含到 Javadoc 中去<br>@Target  用于描述注解的使用范围（类，方法，方法参数变量等）<br>@Inherited 该注解修饰的父类，能被子类继承注解（如果子类没有注解的话）<br>@Repeatable 这个元注解修饰的注解可以同时作用一个对象多次，每次的作用可能不同</p>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>@Override 提示子类必须重写父类方法<br>@SuppressWarnings 阻止编译器警告<br>@Deprecated  用来标记过时的元素 编译器会识别并提醒程序员<br>@SafeVarargs 安全参数<br>@FunctionalInterface JDK1.8引入的 函数式接口注解，例如Runnable 就是一个典型的函数式接口，可以转换为Lambda表达式。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>1.自定义注解的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2.注解还可以添加属性，属性也可以叫成员变量<br>属性的类别可以是8种基本数据类型外加 <strong>类、接口、注解及它们的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    <span class="comment">//这个注解中拥有 id 和 msg 两个属性，在使用的时候，我们可以赋值。</span></span><br><span class="line">    <span class="comment">//参数类型+参数名+()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">@注解名(id=<span class="number">1</span>,msg=<span class="string">"hello world"</span>)<span class="comment">//如果只有一个属性，可以去掉键</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>3.注解可以有默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; </span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "not good"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-注解的原理-目的"><a href="#2-注解的原理-目的" class="headerlink" title="2.注解的原理/目的"></a>2.注解的原理/目的</h1><p>获取属性的值才是使用注解的目的，使用反射的方式（java.lang.reflect.AnnotationElement接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子 通过反射获取注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyField &#123;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用我们的自定义注解</span></span><br><span class="line">    <span class="meta">@MyField</span>(description = <span class="string">"用户名"</span>, length = <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyField</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类模板</span></span><br><span class="line">        Class c = MyFieldTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有字段</span></span><br><span class="line">        <span class="keyword">for</span>(Field f : c.getDeclaredFields())&#123;</span><br><span class="line">            <span class="comment">// 判断这个字段是否有MyField注解</span></span><br><span class="line">            <span class="keyword">if</span>(f.isAnnotationPresent(MyField<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                MyField annotation = f.getAnnotation(MyField<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"字段:["</span> + f.getName() + <span class="string">"], 描述:["</span> + annotation.description() + <span class="string">"], 长度:["</span> + annotation.length() +<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解本身就是Annotation接口的子接口</p>
<h1 id="3-注解的解析"><a href="#3-注解的解析" class="headerlink" title="3.注解的解析"></a>3.注解的解析</h1><p>获取注解中定义的属性值</p>
<h1 id="3-注解的应用场景"><a href="#3-注解的应用场景" class="headerlink" title="3.注解的应用场景"></a>3.注解的应用场景</h1><h3 id="注解的一个应用"><a href="#注解的一个应用" class="headerlink" title="注解的一个应用"></a>注解的一个应用</h3><p>计算方法的运行时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 执行代码块</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了减少代码的冗余<br>通过自定义注解</p>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的排序算法</title>
    <url>/tantian123.github.io/2020/05/21/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>从左到右遍历，每次比较相邻的两个元素，将大的放到右边<br>每次排序，都会选出当前最大的元素，放在最后<br>一直重复，直到选完。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a=new int[n];</span><br><span class="line"></span><br><span class="line">for(int l=n-1;l&gt;0;l--)</span><br><span class="line">    for(int i=0;i&lt;l;i++)</span><br><span class="line">        if(a[i]&gt;a[i+1]) swap(i,i+1);</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>从左到右遍历，每次比较所有元素，保存一个max值<br>每次排序，都会选出当前最大的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxindex;</span><br><span class="line">int[] a=new int[n];</span><br><span class="line">for(int l=n-1;l&gt;=0;l--)&#123;</span><br><span class="line">    for(int i=0;i&lt;l;i++)&#123;</span><br><span class="line">        if(a[maxindex]&lt;a[i])&#123;</span><br><span class="line">            a[maxindex]=a[i];</span><br><span class="line">            maxindex=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(l,maxindex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>分为有序区和无序区  [0<del>i] [i+1</del>n-1]<br>假设第一个元素已被排好序，是有序区的第一个元素<br>从无序区第一个元素开始，从后往前遍历无序区<br>每次，遍历有序区，找到插入的位置，<br>将元素插入（从后往前，每次和前面的元素交换，直到发现比自己小的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">    index=i;</span><br><span class="line">    while(a[index]&gt;a[index-1]&amp;&amp;index&gt;0)&#123;</span><br><span class="line">        swap(a[index],a[index-1]);</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>它以插入排序为基础，将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序(每间隔为i的所有元素选出来组成子列表，然后对每个子序列进行插入排序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>递归<br>基准数（这里我们取第一个）</p>
<p>遍历 将小于基准的放在左边，大于基准的放在右边（使用双指针）<br>然后递归 对基准左边的做一次快排  对基准右边的做一次快排</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">quickSort(0,n-1);</span><br><span class="line"></span><br><span class="line">void quickSort(l,r)&#123;</span><br><span class="line">    int pivot=a[l];//随机选基准</span><br><span class="line">    </span><br><span class="line">    int i=l,j=r;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        while(a[j]&gt;pivot&amp;&amp;i&lt;j) j--;</span><br><span class="line">        while(a[i]&lt;pivot&amp;&amp;i&lt;j) i++;</span><br><span class="line">        swap(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    //最后把基准放到中间</span><br><span class="line">    //j先动，所以最后是i和基准交换</span><br><span class="line">    a[l]=a[i];</span><br><span class="line">    a[i]=pivot;</span><br><span class="line">    </span><br><span class="line">    quickSort(l,pivot-1);</span><br><span class="line">    quickSort(pivot+1,r);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治  先分再治</p>
<ul>
<li>把列表分为两部分，如果列表长度小于等于1，则被排序完成</li>
<li>两部分都排好序后，就进行合并子序列<br>（具体操作：申请一个同样大小的数组，使用两个指针，比较两个指针的数，将更小的数加入新数组，并移动指针，直到有一边的指针出界 之后再将没出界那边的数依次填入新数组）</li>
</ul>
<p>有两种实现，自顶向下 自底向上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mergeSort(0,n-1);</span><br><span class="line"></span><br><span class="line">void mergeSort(l,r)&#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    </span><br><span class="line">    int mid=l+(r-l)/2;</span><br><span class="line">    mergeSort(l,mid);</span><br><span class="line">    mergeSort(mid+1,r);</span><br><span class="line">    merge(l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(l,mid,r)&#123;</span><br><span class="line">    int i=l,j=mid+1;//这里要注意 j=mid+1;</span><br><span class="line">    int[] a2=new int[r-l+1];</span><br><span class="line">    int flag=l;//新数组起始点指针</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        if(a[i]&gt;a[j])&#123;</span><br><span class="line">            a2[flag]==a[j];</span><br><span class="line">            j++;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            a2[flag]==a[i];</span><br><span class="line">            i++;</span><br><span class="line">            flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //把仅剩的元素填入a2</span><br><span class="line">    while(i&lt;=mid) &#123;a2[flag]=a[i];i++&#125;</span><br><span class="line">    while(j&lt;=r) &#123;a2[flag]=a[j];j++&#125;</span><br><span class="line">    </span><br><span class="line">    a = Arrays.copyOfRange(a2, l,r);//复制回去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>选择排序<br>堆是一个完全二叉树，具有以下性质<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆（不要和二叉排序树弄混了）</p>
<p>两种建堆的过程：<br>一种是直接使用原数组，另一种是不断插入</p>
<ul>
<li>1.直接在原数组上改，从A.length/2一直到根结点进行Heapify调整  时间复杂度O(n)</li>
<li>2.假定我们事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。<br>先插入（保持完全二叉树），再heapify，重复<br>时间复杂度O(nlogn)</li>
</ul>
<p><a href="https://visualgo.net/zh/heap" target="_blank" rel="noopener">动画网站</a></p>
<p>整体的步骤：</p>
<ul>
<li>将无需序列构建成一个堆(buildHeap)，根据升序降序需求选择大顶堆或小顶堆</li>
<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端（这个元素就不要管了）</li>
<li>重新调整结构，使其满足堆定义(heapify)，然后继续交换堆顶元素与当前末尾元素，反复执行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a=new int[n];</span><br><span class="line">void heapify(int[] a,int i,int n)&#123;</span><br><span class="line">    //递归出口</span><br><span class="line">    if(i&gt;=n) return;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    int child1=2i+1;</span><br><span class="line">    int child2=2i+2;</span><br><span class="line">    int maxindex=i;</span><br><span class="line">    if(child1&lt;n&amp;&amp;a[child1]&gt;a[i])</span><br><span class="line">        maxindex=child1;</span><br><span class="line">    if(child2&lt;n&amp;&amp;a[child2]&gt;a[i])</span><br><span class="line">        maxindex=child2;</span><br><span class="line">    </span><br><span class="line">    if(maxindex!=i)&#123;</span><br><span class="line">        temp=a[maxindex];</span><br><span class="line">        a[maxindex]=a[i];</span><br><span class="line">        a[i]=temp;</span><br><span class="line">        </span><br><span class="line">        heapify(a,maxindex);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void build_heap(int[] a)&#123;</span><br><span class="line">    int last_node=a.length-1;</span><br><span class="line">    int parent=last_node-1/2;</span><br><span class="line">    for(int i=parent,i&gt;=0;i--)&#123;</span><br><span class="line">        heapify(a,i,a.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序的基本思想是将一个数据表分割成许多buckets，然后每个bucket各自排序，或用不同的排序算法，或者递归的使用bucket sort算法</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序其实是桶排序的一种特殊情况。<br>比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较<br>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>比如比较电话号码</p>
<h3 id="评价一个排序算法"><a href="#评价一个排序算法" class="headerlink" title="评价一个排序算法"></a>评价一个排序算法</h3><p>三个方面：<br>执行效率、内存消耗、稳定性<br>1.时间复杂度</p>
<p>2.稳定  不稳定<br>相等的两个元素 经过排序后，原有的顺序不变</p>
<p>3.内排序 外排序 原地排序<br>排序操作在内存<br>数据大太，所以放在磁盘，所以排序需要通过磁盘和内存进行数据传输<br>空间复杂度O(1)的排序</p>
<p><img src="/images/sort.jpg" alt="image"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>n比较小时，使用插入排序或者选择排序<br>n比较大，使用快排，堆排，归并<br>文件基本有序，使用插入，冒泡，快排<br>要求稳定，归并</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java String类</title>
    <url>/tantian123.github.io/2020/05/21/java-String%E7%B1%BB/</url>
    <content><![CDATA[<p>定义在 java.lang包下</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul>
<li>new方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s=new String();</span><br><span class="line">``` </span><br><span class="line">JVM创建字符串对象，但不存储在字符串常量池</span><br></pre></td></tr></table></figure>
String(char[] value)<br>String(char chars[], int x, int n)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 双引号</span><br></pre></td></tr></table></figure>
String s=”hello”;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM去字符串池找有没有值相等字符串，如果有，则返回找到的字符串引用。否则创建一个新的字符串对象并存储在字符串池</span><br><span class="line"></span><br><span class="line">对象转为字符串toString方法</span><br><span class="line">toString是Object类定义的</span><br><span class="line"></span><br><span class="line"># 常用方法</span><br></pre></td></tr></table></figure>
public int length()</li>
</ul>
<p>public char charAt(int index)</p>
<p>public String substring(int beginIndex)<br>public String substring(int beginIndex, int endIndex)</p>
<p>public int compareTo(String str)</p>
<p>public char[] toCharArray()</p>
<p>public int indexOf(String str)</p>
<p>public String toLowerCase()<br>public String toUpperCase()</p>
<p>String trim()</p>
<p>String[] split(String str)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 属性</span><br><span class="line"></span><br><span class="line"># ==和equals的区别</span><br><span class="line">+ == </span><br><span class="line">对于基本数据类型，比较值</span><br><span class="line">对于引用类型，比较内存地址</span><br><span class="line">+ equals</span><br><span class="line">equals不能比较基本数据类型（它是继承Object类）</span><br><span class="line">如果没对equals进行重写，它比较地址</span><br><span class="line">但是，String/Date类进行了重写，所以只比较值。</span><br><span class="line"></span><br><span class="line"># +号 拼接</span><br><span class="line">因为String是immutable的，每次的操作都会创建一个新的String对象（非常耗时）</span><br><span class="line">字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象</span><br><span class="line"></span><br><span class="line">所以字符串+操作的时候，用StringBuilder更快</span><br><span class="line"></span><br><span class="line">这里去看看运行时常量池的概念</span><br><span class="line"># String StringBuilder和StringBuffer</span><br><span class="line">StringBuilder</span><br><span class="line">StringBuffer</span><br></pre></td></tr></table></figure>
<p>StringBuffer 对象.append(String str)</p>
<p>StringBuffer 对象.reverse();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">区别：StringBuffer是线程安全的（synchronized），而 StringBuilder不是，所以StringBuilder效率更高，锁的获取和释放会带来开销。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实，stringbuffer基本没有适用场景，你应该在所有的情况下选择使用stringbuiler</span><br><span class="line"># intern方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 面试题：</span><br><span class="line">1.String是基本数据类型吗</span><br><span class="line">不是，基本数据类型是 byte short int long char double float boolean</span><br><span class="line">2.String可以被继承吗</span><br><span class="line">不能，是final类</span><br><span class="line">3.String有reverse方法吗</span><br><span class="line">String没有，但StringBuffer和StringBuilder有</span><br><span class="line">4.String, StringBuffer，StringBuilder的区别</span><br><span class="line">5.String是不可变的有什么好处</span><br><span class="line">线程安全 运行时节省大量java堆空间</span><br><span class="line">6.如何判断两个String是否相等</span><br><span class="line"> &quot; == &quot;或者equals</span><br><span class="line">equals是判断两个变量或实例所指向的内存空间的值是不是相同(比较变量的值)</span><br><span class="line">使用&quot;==&quot;操作符时，不仅比较字符串的值，还会比较引用的内存地址(比较内存地址)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.</span><br></pre></td></tr></table></figure>
<p>String a = “hello2”;String b = “hello” + 2;System.out.println((a == b));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出是true</span><br><span class="line">&quot;hello&quot;+2在编译期间就已经被优化成&quot;hello2&quot;，因此在运行期间，变量a和变量b指向的是同一个对象。</span><br></pre></td></tr></table></figure>
<p>String a = “hello2”;String b = “hello”;String c = b + 2;System.out.println((a == c));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果为：false</span><br><span class="line">由于有符号引用的存在，所以 String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象</span><br><span class="line">学完JVM之后的理解，第二个有符号 不被编译器优化，相当于new Stringbuilder.append.append.tostring 所以不是同一个 它是在堆里面的</span><br></pre></td></tr></table></figure>
<p> //str1 += “love”+”java”;        //代码1<br> str1 = str1+”love”+”java”;      //代码2 </p>
<pre><code>代码1的效率比代码2的效率要高，代码1中的&quot;love&quot;+&quot;java&quot;在编译期间会被优化成&quot;lovejava&quot;，而代码2中的不会被优化。
7.讲一下字符串常量池</code></pre>]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合</title>
    <url>/tantian123.github.io/2020/05/21/java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="常见的集合类"><a href="#常见的集合类" class="headerlink" title="常见的集合类"></a>常见的集合类</h1><p>Map和Collection接口</p>
<p>Collection接口的子接口有，Set接口，List接口,Queue接口<br>Map接口有 HashMap TreeMap LinkedHashMap CorrentHashMap HashTable</p>
<p>Set接口有 HashSet TreeSet LinkedHashSet CorrentHashSet<br>List接口有 LinkedList ArrayList Vector<br>Queue接口有 PriorityQueue LinkedList dequeue</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Map存的是键值对，键是唯一的<br>List存的是可重复的<br>Set是不可重复的</p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>LinkedList 基于链表<br>ArrayList 基于数组，线程不安全<br>Vector 线程安全</p>
<p>数组和链表的关键区别：内存连不连续</p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>散列表(数组+链表)   当链表长度大于阈值时，转化为红黑树</p>
<h3 id="Hashtable-线程安全"><a href="#Hashtable-线程安全" class="headerlink" title="Hashtable  线程安全"></a>Hashtable  线程安全</h3><p>底层散列表</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>底层是红黑树</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>底层是散列表和双向链表<br>HashMap中不存在保存顺序，LinkedHashMap专为此特性而生</p>
<h3 id="ConcurrentHashMap-线程安全"><a href="#ConcurrentHashMap-线程安全" class="headerlink" title="ConcurrentHashMap 线程安全"></a>ConcurrentHashMap 线程安全</h3><p>jdk1.8 散列表+红黑树         synchronized只锁定当前链表或红黑二叉树的首节点（因为是链地址法解决冲突）<br>jdk1.7 segments（继承ReetrantLock）+HashEntry数组</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h3 id="HashSet-LinkedHashSet"><a href="#HashSet-LinkedHashSet" class="headerlink" title="HashSet/LinkedHashSet"></a>HashSet/LinkedHashSet</h3><p>基于HashMap/LinkedHashMap</p>
<p>1.Array和ArrayList的区别<br>Array定长，ArrayList 的大小是动态变化的<br>可以包含基本类型和对象类型，ArrayList 只能包含对象类型</p>
<p>2.哪些集合可以存放null？<br>上述集合除了Hashtable和ConcurrentHashMap都可以。</p>
<p>Collection和Collections的区别：<br>Java..util.Collection是一个接口<br>Collections则是集合类的一个工具类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索及线程安全等操作。</p>
<p>3.散列表冲突的解决?<br>开放地址法 寻找下一个空的数组下标<br>再散列法(二次哈希法)  再计算一次<br>链地址法(拉链法)   链表存</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础知识</tag>
        <tag>面向面试编程</tag>
      </tags>
  </entry>
  <entry>
    <title>http总结</title>
    <url>/tantian123.github.io/2020/05/20/http%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP (超文本传输协议)"></a>HTTP (超文本传输协议)</h1><p>定义了 浏览器如何向万维网服务器请求万维网文档,以及服务器如何将文档传给浏览器</p>
<p>HTTP使用TCP，而不是UDP作为它的运输层协议。因此不用担心数据丢失，TCP作为一层抽象屏蔽了底层的细节，HTTP不用管数据的传输。</p>
<h2 id="HTTP是无状态协议"><a href="#HTTP是无状态协议" class="headerlink" title="HTTP是无状态协议"></a>HTTP是无状态协议</h2><p>服务器不保存任何客户端的信息。<br>当我们要保存登录状态的时候，必须使用cookie<br>cookie在请求和响应报文中写入</p>
<h2 id="长连接-短连接"><a href="#长连接-短连接" class="headerlink" title="长连接/短连接"></a>长连接/短连接</h2><p>持久连接（长连接） HTTP默认方式<br>所有请求及响应 经由相同的TCP连接<br>非持久连接（短连接）<br>所有请求及响应 经由分别的TCP连接</p>
<p>优缺点：<br>短连接必须为每个请求 维护一个新的连接，每个这样的连接，都要分配TCP的缓冲区和变量</p>
<h1 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h1><h2 id="1-HTTP请求报文"><a href="#1-HTTP请求报文" class="headerlink" title="1.HTTP请求报文"></a>1.HTTP请求报文</h2><p>line(status line/header line/null line)+body<br>先看图：<br><img src="/images/http.jpg" alt="http"></p>
<p>第一行叫做请求行，后面的叫做首部行</p>
<h3 id="1-1-请求行"><a href="#1-1-请求行" class="headerlink" title="1.1 请求行"></a>1.1 请求行</h3><p>三个字段：方法字段+URL字段+HTTP协议版本字段</p>
<ul>
<li>方法字段：GET POST HEAD PUT DELETE</li>
<li>URL字段：对象的URL地址(不包括域名)</li>
<li>HTTP协议版本字段<h3 id="1-2-首部行（请求头）"><a href="#1-2-首部行（请求头）" class="headerlink" title="1.2 首部行（请求头）"></a>1.2 首部行（请求头）</h3>由关键字/值对组成，每行一对</li>
</ul>
<p>User-Agent : 产生请求的浏览器类型<br>Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型<br>Content-Type：发送端发送的实体数据的数据类型。<br>比如，Content-Type：text/html（application/json）表示发送的是html类型。<br>Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</p>
<h3 id="1-3空行-用来通知服务器以下不存在请求头了"><a href="#1-3空行-用来通知服务器以下不存在请求头了" class="headerlink" title="1.3空行 用来通知服务器以下不存在请求头了"></a>1.3空行 用来通知服务器以下不存在请求头了</h3><h3 id="1-4请求体（不一定有）"><a href="#1-4请求体（不一定有）" class="headerlink" title="1.4请求体（不一定有）"></a>1.4请求体（不一定有）</h3><p>GET没有，POST有</p>
<h2 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h2><h3 id="2-1状态行"><a href="#2-1状态行" class="headerlink" title="2.1状态行"></a>2.1状态行</h3><p>三个字段：服务器HTTP协议版本，响应状态码，状态码的文本描述</p>
<ul>
<li>服务器HTTP协议版本</li>
<li>状态码 例如200</li>
<li>状态码的文本描述 例如OK </li>
</ul>
<h3 id="2-2首部行（消息报头）"><a href="#2-2首部行（消息报头）" class="headerlink" title="2.2首部行（消息报头）"></a>2.2首部行（消息报头）</h3><h3 id="2-3空行"><a href="#2-3空行" class="headerlink" title="2.3空行"></a>2.3空行</h3><h3 id="2-4响应体"><a href="#2-4响应体" class="headerlink" title="2.4响应体"></a>2.4响应体</h3><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>由3位数字组成，第一个数字定义了响应的类别</p>
<ul>
<li>1XX Information 信息性（接收的请求正在处理）</li>
<li>2XX Success 成功（请求处理完毕）</li>
<li>3XX Redirection 重定向（需要附加操作以完成请求）</li>
<li>4XX Client Error 客户端错误（语法错误或服务器无法处理请求）</li>
<li>5XX Server Error 服务器错误（服务器处理请求的过程中出错）</li>
</ul>
<h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><ul>
<li>200 OK    客户端请求成功</li>
<li>204 No Content   无内容</li>
<li>301 Moved Permanently  资源永久移动（永久重定向）</li>
<li>302 Found  资源临时移动（临时重定向）</li>
<li>303 See Other   303功能与302一样，区别只是303明确客户端应该使用GET访问</li>
<li>304 Not Modified 这个码虽然是3XX，但是和重定向没关系（资源已找到，但是没有符合条件）</li>
<li>307 Temporary Redirect   </li>
<li>400 Bad Request 请求报文语法错误</li>
<li>401 Unauthorized 第一次返回求认证，第二次返回认证失败</li>
<li>403 Forbidden 服务器不允许访问那个资源</li>
<li>404 Not Found 找不到请求的资源</li>
<li>500 服务器出错了</li>
<li>503 服务器停止工作或者在忙</li>
</ul>
<h1 id="HTTP1-0-HTTP1-1区别"><a href="#HTTP1-0-HTTP1-1区别" class="headerlink" title="HTTP1.0 HTTP1.1区别"></a>HTTP1.0 HTTP1.1区别</h1><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 1.0需要使用<strong>keep-alive参数</strong>来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数</p>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>HTTP2.0的主要优点有采用二进制帧封装，传输变成多路复用，流量控制算法优化，服务器端推送，首部压缩，优先级等特点</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p>
<p>端口是443</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>SSL建立连接过程</p>
<h1 id="现代网络应用的两种主流体系结构："><a href="#现代网络应用的两种主流体系结构：" class="headerlink" title="现代网络应用的两种主流体系结构："></a>现代网络应用的两种主流体系结构：</h1><ul>
<li>C/S 客户端/服务器   例子有WEB应用程序</li>
<li>P2P 对等</li>
</ul>
<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>套接字是一台主机的应用层和传输层之间的<strong>接口</strong><br>进程（应用层）通过套接字接口访问TCP（传输层）</p>
<h1 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h1><p>URL地址=主机名+对象的路径名</p>
<p>cookie详解</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>1.HTTP端口<br>默认使用80端口，客户端向服务器的80端口建立一个TCP连接<br>2.浏览器点开网页的过程<br>(1)浏览器分析URL<br>(2)浏览器向dns服务器请求解析IP地址<br>(3)DNS解析出IP地址<br>(4)浏览器与服务器建立TCP连接<br>(5)请求文件-响应<br>(6)关闭TCP连接<br>(7)浏览器显示</p>
<p>3.请求一个HTML的时间<br>客户端前两次握手，是一个RTT<br>客户端将第三次握手的ACK报文与一个HTTP请求报文结合发送，然后返回HTML文件，这是一个RTT<br>所以一共花费 2个RTT</p>
<p>4.301 302 的区别  使用场景 什么是重定向 为什么需要重定向<br>301是永久重定向 网址替换为重定向后的网站<br>302是暂时重定向 保留旧的网址</p>
<p>301适用于域名跳转</p>
<ul>
<li>http跳转到https<br>例如我们输入 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>跳转到<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li>
<li>二级域名跳转到主域名</li>
<li>404页面失效跳转到新页面</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>tcp面试题</title>
    <url>/tantian123.github.io/2020/05/20/tcp%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="tcp总结"><a href="#tcp总结" class="headerlink" title="tcp总结"></a>tcp总结</h1><ul>
<li><p>tcp/udp首部报文</p>
</li>
<li><p>三次握手 四次挥手 状态变换</p>
</li>
<li><p>tcp的流量控制</p>
</li>
<li><p>tcp的拥塞控制</p>
</li>
<li><p>常见的面试题</p>
</li>
</ul>
<p>tcp连接的每一端口，都由一个接收缓存、一个发送缓存和几个变量（lastByteRead RcvWindow Conwin）</p>
<p>RTT 往返时延<br>分组从客户端到服务器再回到客户端的时间<br>=分组传播时延+路由器/交换机上的排队时延+分组处理时延</p>
<h2 id="1-tcp-udp报文"><a href="#1-tcp-udp报文" class="headerlink" title="1.tcp/udp报文"></a>1.tcp/udp报文</h2><p>tcp报文=tcp首部字段+数据字段<br>源端口，目的端口，序号seq，确认号ack，控制位（ACK SYN FIN）,窗口</p>
<p><img src="/images/1.jpg" alt="tcp"></p>
<p>控制位 是6bit</p>
<p>udp报文=源端口号+目的端口号+长度（总长度）+校验和+数据字段</p>
<h3 id="tcp-udp的区别"><a href="#tcp-udp的区别" class="headerlink" title="tcp/udp的区别"></a>tcp/udp的区别</h3><ul>
<li>tcp 面向连接 可靠 面向字节流<br>udp 无连接 不可靠 面向报文</li>
<li>TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。TCP通过慢开始、拥塞避免、快重传、快恢复等算法进行拥塞控制。</li>
<li>UDP首开销小，只有8个字节。TCP首部是20个字节</li>
</ul>
<h2 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2.三次握手 四次挥手"></a>2.三次握手 四次挥手</h2><p><strong>主要关注控制位，序号，确认号，状态</strong><br><img src="/images/2.jpg" alt="tcp"></p>
<p>序列号/确认号的作用<br>序列号：<br>每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号<br>确认号：<br>告诉对方我已经收到xx，下次期望收到对方下个报文段的第一个数据字节的序号（下次的第一个字节）</p>
<p>序列号保证了传输的数据包的顺序</p>
<p>用tcp发送了一个数据包后，会把它放到重发队列里，同时计时，<br>如果收到了这个包的确认信息，就会将这个包从重发队列中删除，<br>如果在计时器超时内，没收到确认信息，就会进行重发</p>
<p>初始序列号(ISN) 是随机值  有client_isn和server_isn</p>
<h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1.三次握手"></a>2.1.三次握手</h3><ol>
<li><p>SYN=1 seq=x （也就是client_isn）<br>客户端发送SYN包到服务器<br>此后，客户端状态SYN_SENT</p>
</li>
<li><p>ACK=1 SYN=1 seq=y（也就是server_isn） ack=x+1<br>服务器收到SYN包，服务器返回SYNACK包，<br>此后，服务器状态SYN_RECV</p>
</li>
<li><p>ACK=1 seq=x+1  ack=y+1  SYN=0<br>客户端收到SYNACK包，发送ACK包给服务器<br>服务器收到<br>此后，客户端/服务器状态 ESTABLISHED（TCP连接成功）</p>
</li>
</ol>
<p>通过三次握手，通信双方了解了如下信息<br>1、对方报文发送的开始序号。<br>2、对方发送数据的缓冲区大小。<br>3、能被接收的最大报文段长度MSS。<br>4、被支持的TCP选项。</p>
<p>另一种理解，通过三次握手，通信双方都明确自己和对方的收、发能力是正常的<br>第一次握手（服务器端知道自己的收能力，和客户端的发能力）<br>第二次握手（客户端知道自己的收发能力和服务器端的收发能力）<br>第三次握手（服务器知道自己的发能力和客户端的收能力）</p>
<h3 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2.四次挥手"></a>2.2.四次挥手</h3><ol>
<li><p>FIN=1 ACK=1 seq=x ack=z<br>客户端发出连接释放报文<br>此后，客户端状态FIN_WAIT_1</p>
</li>
<li><p>ACK=1 seq=z ack=x+1<br>服务器收到后，发出确认报文（此时服务器还没发完，不能关闭）<br>此后，客户端状态  FIN_WAIT_1<br>服务器端状态  CLOSE_WAIT</p>
</li>
<li><p>FIN=1 ACK=1 seq=y ack=x+1<br>服务器传完后，就发送连接释放报文<br>此后，服务器状态LAST_ACK </p>
</li>
<li><p>ACK=1 seq=x+1 ack=y+1<br>客户端收到连接释放报文，发出确认报文<br>此后，客户端进入TIME_WAIT状态</p>
</li>
</ol>
<p>此时还要等待2MSL（最长报文段寿命）客户端才撤销TCB 进入CLOSED状态<br>服务器端收到客户端的确认报文，立刻进入CLOSED状态，所以服务器结束得早一点</p>
<h2 id="3-tcp流量控制"><a href="#3-tcp流量控制" class="headerlink" title="3.tcp流量控制"></a>3.tcp流量控制</h2><p>tcp让发送方维护一个接收窗口的变量来实现流量控制   RcvWindow<br>接收窗口用于告诉发送方，你的接收方还有多少缓存可用<br>两边都各自维护一个接收窗口，同时TCP不允许缓存溢出<br>主机B把当前的接收窗口值放入它发给主机A的TCP报文段里的接收窗口字段，通过控制未确认的数据量在接收窗口以内</p>
<p>当然，这个方案存在一个技术问题，<br>考虑一种特殊情况，当接收方B缓存满了，那么发送方A的接收窗口设为0，而之后如果接收方B缓存清空，发送方A就一直阻塞，不发。<br>解决方案：TCP规约中要求，接收窗口为0时，发送方A会继续发送只有一个字节的报文段，一旦缓存清空了，接收方B就会返回一个非0的窗口值。</p>
<h2 id="4-tcp拥塞控制"><a href="#4-tcp拥塞控制" class="headerlink" title="4.tcp拥塞控制"></a>4.tcp拥塞控制</h2><p>每一端都记录一个变量——拥塞窗口，CongWin。<br>它对一个TCP发送方，发送的速率进行了限制。<br>即 发送方未确认的数据量   (LastByteSend-LastByteAcked)&lt;=min(CongWin,RcvWindow)</p>
<p>TCP是如何感知阻塞的呢？</p>
<p>解决办法：<br>1.慢启动<br>2.拥塞避免<br>3.快重传<br>4.快恢复</p>
<h2 id="5-常见的面试题"><a href="#5-常见的面试题" class="headerlink" title="5.常见的面试题"></a>5.常见的面试题</h2><p>为什么需要初始序号<br>    为了避免安全攻击。初始序号是随机的<br>为什么不是二次握手<br>    主要为了防止A已失效的连接请求报文段突然又传送到了B，因而产生错误。如果没有第三次握手，B收到消息就会立马建立连接。<br>为什么要等待2MSL/为什么需要TIME_WAIT<br>    MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”<br>    为了保证A发送的最后一个ACK报文能够到达B ，如果A不等待，此时B没收到A的ACK，B就不会关闭</p>
<p>TIME_WAIT的危害<br>    在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态（大量TIME_WAIT的条件：高并发，服务器主动关闭）<br>    服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。<br>如何解决<br>    允许端口可重用<br>    服务器不主动关闭连接</p>
<p>为什么是四次挥手（关键在于挥手是需要等的，而握手是随时可以的）<br>    第一次挥手 A不主动发了，仍然可以接收<br>    第二次挥手 B告诉A 我知道你的情况了 但是我还没发完，等会<br>    第三次挥手 B告诉A 我处理完了，我不主动发了<br>    第四次挥手 A告诉B 你可以关闭接收了</p>
<p>syn洪泛攻击<br>    服务器响应SYN 会分配并初始化变量和缓存，消耗资源<br>    攻击者发送大量的TCP SYN报文段，而不进行第三次握手。导致服务器资源消耗殆尽。<br>    现在的防御手段，SYN cookies<br>三次握手过程中可以携带数据吗<br>    第三次握手允许携带数据<br>linux系统的nmap工具 （端口扫描工具）<br>    没用过</p>
]]></content>
      <tags>
        <tag>面向面试编程</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 136. Single Number</title>
    <url>/tantian123.github.io/2020/04/02/leetcode-136-Single-Number/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>这是一道Bit Operation位操作的题目<br>异或XOR操作：相同为0，不同为1<br>相同元素出现两次即出现两次变号  0-&gt;1-&gt;0(或1-&gt;0-&gt;1)<br>只出现一次的元素只变号一次     0-&gt;1(或1-&gt;0)</p>
<p>文字描述不够直观<br><strong>接下来直接举例，[1,2,3,4,1,2,3]  输出4</strong><br>res=1 ^ 2 ^ 3 ^ 4 ^ 1^ 2 ^ 3=(1 ^ 1) ^ (2 ^ 2)^(3 ^ 3)^ 4=0^ 0^ 0^4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] -&gt; 0-0-0-1   //与下面的进行异或操作</span><br><span class="line">[2] -&gt; 0-0-1-0   //(0-0-0-1)+(0-0-1-0)=(0-0-1-1) </span><br><span class="line">[3] -&gt; 0-0-1-1   //(0-0-1-1)+(0-0-1-1)=(0-0-0-0)</span><br><span class="line">[4] -&gt; 0-1-0-0   //(0-0-0-0)+(0-1-0-0)=(0-1-0-0)</span><br><span class="line">[1] -&gt; 0-0-0-1   //(0-1-0-0)+(0-0-0-1)=(0-1-0-1)</span><br><span class="line">[2] -&gt; 0-0-1-0   //(0-1-0-1)+(0-0-1-0)=(0-1-1-1)</span><br><span class="line">[3] -&gt; 0-0-1-1   //(0-1-1-1)+(0-0-1-1)=(0-1-0-0)</span><br><span class="line">//最后输出结果为0-1-0-0，即为十进制数4.</span><br></pre></td></tr></table></figure>

<h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>java进行按位异或操作  c = a ^ b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">            nums[i]=nums[i-1]^nums[i];</span><br><span class="line">        return nums[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令</title>
    <url>/tantian123.github.io/2020/04/02/hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line">简写为</span><br><span class="line">hexo n &quot;我的博客&quot;</span><br></pre></td></tr></table></figure>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate </span><br><span class="line">简写为</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">简写为</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h3 id="预览博文效果"><a href="#预览博文效果" class="headerlink" title="预览博文效果"></a>预览博文效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debug 在本地浏览器的localhost:4000</span><br></pre></td></tr></table></figure>
<h3 id="三连"><a href="#三连" class="headerlink" title="三连"></a>三连</h3><p>在blog根目录下的source文件夹中的_post文件夹中打开命令行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="导入图片"><a href="#导入图片" class="headerlink" title="导入图片"></a>导入图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![简介](/images/xx.jpg)</span><br></pre></td></tr></table></figure>

<h3 id="新增分类选项"><a href="#新增分类选项" class="headerlink" title="新增分类选项"></a>新增分类选项</h3><p>一篇文章只会添加到一个分类中</p>
<p>1.创建分类页面（第一次才要）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>2.找到source/categories/index.md<br>加入一个键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: categories</span><br></pre></td></tr></table></figure>
<p>3.给每篇文章加属性<br>给文章添加“categories”属性<br>表示添加到到“Hexo”这个分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>




<h3 id="新增标签选项"><a href="#新增标签选项" class="headerlink" title="新增标签选项"></a>新增标签选项</h3><p>一篇文章有多个标签</p>
<p>1.生成“标签”页并添加tpye属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>2.在tags文件夹下，找到index.md这个文件<br>加入一个键值对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: tags</span><br></pre></td></tr></table></figure>

<p>3.为其添加tags属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- 日记</span><br><span class="line">- 2020</span><br><span class="line">- 私密</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
